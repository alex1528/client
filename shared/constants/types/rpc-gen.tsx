/* eslint-disable */

// This file is auto-generated by client/protocol/Makefile.
import {call, CallEffect, Effect} from 'redux-saga/effects'
import {getEngine as engine, getEngineSaga} from '../../engine/require'
import * as Gregor1 from './rpc-gregor-gen'
export {Gregor1}
export type Bool = boolean
export type Boolean = boolean
export type Bytes = Buffer
export type Double = number
export type Int = number
export type Int64 = number
export type Long = number
export type String = string
export type Uint = number
export type Uint64 = number
type WaitingKey = string | Array<string>
export type IncomingErrorCallback = (err: {code?: number; desc?: string} | null) => void
type IncomingReturn = Effect | null | void | false | Array<Effect | null | void | false>

export type MessageTypes = {
  'keybase.1.NotifyApp.exit': {
    inParam: void
    outParam: void
  }
  'keybase.1.NotifyAudit.boxAuditError': {
    inParam: {readonly message: String}
    outParam: void
  }
  'keybase.1.NotifyAudit.rootAuditError': {
    inParam: {readonly message: String}
    outParam: void
  }
  'keybase.1.NotifyBadges.badgeState': {
    inParam: {readonly badgeState: BadgeState}
    outParam: void
  }
  'keybase.1.NotifyCanUserPerform.canUserPerformChanged': {
    inParam: {readonly teamName: String}
    outParam: void
  }
  'keybase.1.NotifyDeviceClone.deviceCloneCountChanged': {
    inParam: {readonly newClones: Int}
    outParam: void
  }
  'keybase.1.NotifyEmailAddress.emailAddressVerified': {
    inParam: {readonly emailAddress: EmailAddress}
    outParam: void
  }
  'keybase.1.NotifyEphemeral.newTeamEk': {
    inParam: {readonly id: TeamID; readonly generation: EkGeneration}
    outParam: void
  }
  'keybase.1.NotifyFS.FSActivity': {
    inParam: {readonly notification: FSNotification}
    outParam: void
  }
  'keybase.1.NotifyFS.FSEditListResponse': {
    inParam: {readonly edits: FSFolderEditHistory; readonly requestID: Int}
    outParam: void
  }
  'keybase.1.NotifyFS.FSFavoritesChanged': {
    inParam: void
    outParam: void
  }
  'keybase.1.NotifyFS.FSOnlineStatusChanged': {
    inParam: {readonly online: Boolean}
    outParam: void
  }
  'keybase.1.NotifyFS.FSOverallSyncStatusChanged': {
    inParam: {readonly status: FolderSyncStatus}
    outParam: void
  }
  'keybase.1.NotifyFS.FSPathUpdated': {
    inParam: {readonly path: String}
    outParam: void
  }
  'keybase.1.NotifyFS.FSSyncActivity': {
    inParam: {readonly status: FSPathSyncStatus}
    outParam: void
  }
  'keybase.1.NotifyFS.FSSyncStatusResponse': {
    inParam: {readonly status: FSSyncStatus; readonly requestID: Int}
    outParam: void
  }
  'keybase.1.NotifyFavorites.favoritesChanged': {
    inParam: {readonly uid: UID}
    outParam: void
  }
  'keybase.1.NotifyKeyfamily.keyfamilyChanged': {
    inParam: {readonly uid: UID}
    outParam: void
  }
  'keybase.1.NotifyPGP.pgpKeyInSecretStoreFile': {
    inParam: void
    outParam: void
  }
  'keybase.1.NotifyPaperKey.paperKeyCached': {
    inParam: {readonly uid: UID; readonly encKID: KID; readonly sigKID: KID}
    outParam: void
  }
  'keybase.1.NotifyPhoneNumber.phoneNumberAdded': {
    inParam: {readonly phoneNumber: PhoneNumber}
    outParam: void
  }
  'keybase.1.NotifyPhoneNumber.phoneNumberSuperseded': {
    inParam: {readonly phoneNumber: PhoneNumber}
    outParam: void
  }
  'keybase.1.NotifyPhoneNumber.phoneNumberVerified': {
    inParam: {readonly phoneNumber: PhoneNumber}
    outParam: void
  }
  'keybase.1.NotifyService.shutdown': {
    inParam: {readonly code: Int}
    outParam: void
  }
  'keybase.1.NotifySession.clientOutOfDate': {
    inParam: {readonly upgradeTo: String; readonly upgradeURI: String; readonly upgradeMsg: String}
    outParam: void
  }
  'keybase.1.NotifySession.loggedIn': {
    inParam: {readonly username: String}
    outParam: void
  }
  'keybase.1.NotifySession.loggedOut': {
    inParam: void
    outParam: void
  }
  'keybase.1.NotifyTeam.avatarUpdated': {
    inParam: {readonly name: String; readonly formats?: Array<AvatarFormat> | null; readonly typ: AvatarUpdateType}
    outParam: void
  }
  'keybase.1.NotifyTeam.newlyAddedToTeam': {
    inParam: {readonly teamID: TeamID}
    outParam: void
  }
  'keybase.1.NotifyTeam.teamAbandoned': {
    inParam: {readonly teamID: TeamID}
    outParam: void
  }
  'keybase.1.NotifyTeam.teamChangedByID': {
    inParam: {readonly teamID: TeamID; readonly latestSeqno: Seqno; readonly implicitTeam: Boolean; readonly changes: TeamChangeSet}
    outParam: void
  }
  'keybase.1.NotifyTeam.teamChangedByName': {
    inParam: {readonly teamName: String; readonly latestSeqno: Seqno; readonly implicitTeam: Boolean; readonly changes: TeamChangeSet}
    outParam: void
  }
  'keybase.1.NotifyTeam.teamDeleted': {
    inParam: {readonly teamID: TeamID}
    outParam: void
  }
  'keybase.1.NotifyTeam.teamExit': {
    inParam: {readonly teamID: TeamID}
    outParam: void
  }
  'keybase.1.NotifyTracking.trackingChanged': {
    inParam: {readonly uid: UID; readonly username: String; readonly isTracking: Boolean}
    outParam: void
  }
  'keybase.1.NotifyUnverifiedTeamList.teamListUnverifiedChanged': {
    inParam: {readonly teamName: String}
    outParam: void
  }
  'keybase.1.NotifyUsers.passwordChanged': {
    inParam: void
    outParam: void
  }
  'keybase.1.NotifyUsers.userChanged': {
    inParam: {readonly uid: UID}
    outParam: void
  }
  'keybase.1.SimpleFS.SimpleFSGetHTTPAddressAndToken': {
    inParam: void
    outParam: SimpleFSGetHTTPAddressAndTokenResponse
  }
  'keybase.1.SimpleFS.simpleFSAreWeConnectedToMDServer': {
    inParam: void
    outParam: Boolean
  }
  'keybase.1.SimpleFS.simpleFSCancel': {
    inParam: {readonly opID: OpID}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSCheck': {
    inParam: {readonly opID: OpID}
    outParam: OpProgress
  }
  'keybase.1.SimpleFS.simpleFSCheckReachability': {
    inParam: void
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSClearConflictState': {
    inParam: {readonly path: Path}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSCopyRecursive': {
    inParam: {readonly opID: OpID; readonly src: Path; readonly dest: Path}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSFinishResolvingConflict': {
    inParam: {readonly path: Path}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSFolderSyncConfigAndStatus': {
    inParam: {readonly path: Path}
    outParam: FolderSyncConfigAndStatus
  }
  'keybase.1.SimpleFS.simpleFSList': {
    inParam: {readonly opID: OpID; readonly path: Path; readonly filter: ListFilter; readonly refreshSubscription: Boolean}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSListFavorites': {
    inParam: void
    outParam: FavoritesResult
  }
  'keybase.1.SimpleFS.simpleFSListRecursiveToDepth': {
    inParam: {readonly opID: OpID; readonly path: Path; readonly filter: ListFilter; readonly refreshSubscription: Boolean; readonly depth: Int}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSMove': {
    inParam: {readonly opID: OpID; readonly src: Path; readonly dest: Path}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSOpen': {
    inParam: {readonly opID: OpID; readonly dest: Path; readonly flags: OpenFlags}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSReadList': {
    inParam: {readonly opID: OpID}
    outParam: SimpleFSListResult
  }
  'keybase.1.SimpleFS.simpleFSRemove': {
    inParam: {readonly opID: OpID; readonly path: Path; readonly recursive: Boolean}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSSetFolderSyncConfig': {
    inParam: {readonly path: Path; readonly config: FolderSyncConfig}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSSetNotificationThreshold': {
    inParam: {readonly threshold: Int64}
    outParam: void
  }
  'keybase.1.SimpleFS.simpleFSSettings': {
    inParam: void
    outParam: FSSettings
  }
  'keybase.1.SimpleFS.simpleFSStat': {
    inParam: {readonly path: Path; readonly identifyBehavior?: TLFIdentifyBehavior | null; readonly refreshSubscription: Boolean}
    outParam: Dirent
  }
  'keybase.1.SimpleFS.simpleFSSyncConfigAndStatus': {
    inParam: void
    outParam: SyncConfigAndStatusRes
  }
  'keybase.1.SimpleFS.simpleFSSyncStatus': {
    inParam: {readonly filter: ListFilter}
    outParam: FSSyncStatus
  }
  'keybase.1.SimpleFS.simpleFSUserEditHistory': {
    inParam: void
    outParam: Array<FSFolderEditHistory> | null
  }
  'keybase.1.SimpleFS.simpleFSWait': {
    inParam: {readonly opID: OpID}
    outParam: void
  }
  'keybase.1.account.emailChange': {
    inParam: {readonly newEmail: String}
    outParam: void
  }
  'keybase.1.account.getLockdownMode': {
    inParam: void
    outParam: GetLockdownResponse
  }
  'keybase.1.account.hasServerKeys': {
    inParam: void
    outParam: HasServerKeysRes
  }
  'keybase.1.account.passphraseChange': {
    inParam: {readonly oldPassphrase: String; readonly passphrase: String; readonly force: Boolean}
    outParam: void
  }
  'keybase.1.account.passphraseCheck': {
    inParam: {readonly passphrase: String}
    outParam: Boolean
  }
  'keybase.1.account.recoverUsernameWithEmail': {
    inParam: {readonly email: String}
    outParam: void
  }
  'keybase.1.account.setLockdownMode': {
    inParam: {readonly enabled: Boolean}
    outParam: void
  }
  'keybase.1.apiserver.Delete': {
    inParam: {readonly endpoint: String; readonly args?: Array<StringKVPair> | null; readonly httpStatus?: Array<Int> | null; readonly appStatusCode?: Array<Int> | null}
    outParam: APIRes
  }
  'keybase.1.apiserver.Get': {
    inParam: {readonly endpoint: String; readonly args?: Array<StringKVPair> | null; readonly httpStatus?: Array<Int> | null; readonly appStatusCode?: Array<Int> | null}
    outParam: APIRes
  }
  'keybase.1.apiserver.GetWithSession': {
    inParam: {readonly endpoint: String; readonly args?: Array<StringKVPair> | null; readonly httpStatus?: Array<Int> | null; readonly appStatusCode?: Array<Int> | null}
    outParam: APIRes
  }
  'keybase.1.apiserver.Post': {
    inParam: {readonly endpoint: String; readonly args?: Array<StringKVPair> | null; readonly httpStatus?: Array<Int> | null; readonly appStatusCode?: Array<Int> | null}
    outParam: APIRes
  }
  'keybase.1.apiserver.PostJSON': {
    inParam: {readonly endpoint: String; readonly args?: Array<StringKVPair> | null; readonly JSONPayload?: Array<StringKVPair> | null; readonly httpStatus?: Array<Int> | null; readonly appStatusCode?: Array<Int> | null}
    outParam: APIRes
  }
  'keybase.1.appState.powerMonitorEvent': {
    inParam: {readonly event: String}
    outParam: void
  }
  'keybase.1.avatars.loadTeamAvatars': {
    inParam: {readonly names?: Array<String> | null; readonly formats?: Array<AvatarFormat> | null}
    outParam: LoadAvatarsRes
  }
  'keybase.1.avatars.loadUserAvatars': {
    inParam: {readonly names?: Array<String> | null; readonly formats?: Array<AvatarFormat> | null}
    outParam: LoadAvatarsRes
  }
  'keybase.1.config.getAllProvisionedUsernames': {
    inParam: void
    outParam: AllProvisionedUsernames
  }
  'keybase.1.config.getBootstrapStatus': {
    inParam: void
    outParam: BootstrapStatus
  }
  'keybase.1.config.getConfig': {
    inParam: void
    outParam: Config
  }
  'keybase.1.config.getRememberPassphrase': {
    inParam: void
    outParam: Boolean
  }
  'keybase.1.config.getUpdateInfo': {
    inParam: void
    outParam: UpdateInfo
  }
  'keybase.1.config.getUpdateInfo2': {
    inParam: {readonly platform?: String | null; readonly version?: String | null}
    outParam: UpdateInfo2
  }
  'keybase.1.config.getValue': {
    inParam: {readonly path: String}
    outParam: ConfigValue
  }
  'keybase.1.config.helloIAm': {
    inParam: {readonly details: ClientDetails}
    outParam: void
  }
  'keybase.1.config.logSend': {
    inParam: {readonly statusJSON: String; readonly feedback: String; readonly sendLogs: Boolean}
    outParam: LogSendID
  }
  'keybase.1.config.setRememberPassphrase': {
    inParam: {readonly remember: Boolean}
    outParam: void
  }
  'keybase.1.config.setValue': {
    inParam: {readonly path: String; readonly value: ConfigValue}
    outParam: void
  }
  'keybase.1.config.startUpdateIfNeeded': {
    inParam: void
    outParam: void
  }
  'keybase.1.config.waitForClient': {
    inParam: {readonly clientType: ClientType; readonly timeout: DurationSec}
    outParam: Boolean
  }
  'keybase.1.cryptocurrency.registerAddress': {
    inParam: {readonly address: String; readonly force: Boolean; readonly wantedFamily: String; readonly sigVersion?: SigVersion | null}
    outParam: RegisterAddressRes
  }
  'keybase.1.ctl.dbClean': {
    inParam: {readonly force: Boolean; readonly dbType: DbType}
    outParam: void
  }
  'keybase.1.ctl.dbNuke': {
    inParam: void
    outParam: void
  }
  'keybase.1.ctl.stop': {
    inParam: {readonly exitCode: ExitCode}
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerChatUI': {
    inParam: void
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerGregorFirehoseFiltered': {
    inParam: {readonly systems?: Array<String> | null}
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerHomeUI': {
    inParam: void
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerIdentify3UI': {
    inParam: void
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerIdentifyUI': {
    inParam: void
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerRekeyUI': {
    inParam: void
    outParam: void
  }
  'keybase.1.delegateUiCtl.registerSecretUI': {
    inParam: void
    outParam: void
  }
  'keybase.1.device.checkDeviceNameFormat': {
    inParam: {readonly name: String}
    outParam: Boolean
  }
  'keybase.1.device.deviceAdd': {
    inParam: void
    outParam: void
  }
  'keybase.1.device.deviceHistoryList': {
    inParam: void
    outParam: Array<DeviceDetail> | null
  }
  'keybase.1.device.dismissDeviceChangeNotifications': {
    inParam: void
    outParam: void
  }
  'keybase.1.favorite.favoriteAdd': {
    inParam: {readonly folder: Folder}
    outParam: void
  }
  'keybase.1.favorite.favoriteIgnore': {
    inParam: {readonly folder: Folder}
    outParam: void
  }
  'keybase.1.git.createPersonalRepo': {
    inParam: {readonly repoName: GitRepoName}
    outParam: RepoID
  }
  'keybase.1.git.createTeamRepo': {
    inParam: {readonly repoName: GitRepoName; readonly teamName: TeamName; readonly notifyTeam: Boolean}
    outParam: RepoID
  }
  'keybase.1.git.deletePersonalRepo': {
    inParam: {readonly repoName: GitRepoName}
    outParam: void
  }
  'keybase.1.git.deleteTeamRepo': {
    inParam: {readonly repoName: GitRepoName; readonly teamName: TeamName; readonly notifyTeam: Boolean}
    outParam: void
  }
  'keybase.1.git.getAllGitMetadata': {
    inParam: void
    outParam: Array<GitRepoResult> | null
  }
  'keybase.1.git.getGitMetadata': {
    inParam: {readonly folder: Folder}
    outParam: Array<GitRepoResult> | null
  }
  'keybase.1.git.setTeamRepoSettings': {
    inParam: {readonly folder: Folder; readonly repoID: RepoID; readonly channelName?: String | null; readonly chatDisabled: Boolean}
    outParam: void
  }
  'keybase.1.gpgUi.confirmDuplicateKeyChosen': {
    inParam: void
    outParam: Boolean
  }
  'keybase.1.gpgUi.confirmImportSecretToExistingKey': {
    inParam: void
    outParam: Boolean
  }
  'keybase.1.gpgUi.getTTY': {
    inParam: void
    outParam: String
  }
  'keybase.1.gpgUi.selectKey': {
    inParam: {readonly keys?: Array<GPGKey> | null}
    outParam: String
  }
  'keybase.1.gpgUi.selectKeyAndPushOption': {
    inParam: {readonly keys?: Array<GPGKey> | null}
    outParam: SelectKeyRes
  }
  'keybase.1.gpgUi.sign': {
    inParam: {readonly msg: Bytes; readonly fingerprint: Bytes}
    outParam: String
  }
  'keybase.1.gpgUi.wantToAddGPGKey': {
    inParam: void
    outParam: Boolean
  }
  'keybase.1.gregor.dismissCategory': {
    inParam: {readonly category: Gregor1.Category}
    outParam: void
  }
  'keybase.1.gregor.dismissItem': {
    inParam: {readonly id: Gregor1.MsgID}
    outParam: void
  }
  'keybase.1.gregor.getState': {
    inParam: void
    outParam: Gregor1.State
  }
  'keybase.1.gregor.injectItem': {
    inParam: {readonly cat: String; readonly body: String; readonly dtime: Gregor1.TimeOrOffset}
    outParam: Gregor1.MsgID
  }
  'keybase.1.gregor.updateCategory': {
    inParam: {readonly category: String; readonly body: String; readonly dtime: Gregor1.TimeOrOffset}
    outParam: Gregor1.MsgID
  }
  'keybase.1.gregor.updateItem': {
    inParam: {readonly msgID: Gregor1.MsgID; readonly cat: String; readonly body: String; readonly dtime: Gregor1.TimeOrOffset}
    outParam: Gregor1.MsgID
  }
  'keybase.1.gregorUI.pushOutOfBandMessages': {
    inParam: {readonly oobm?: Array<Gregor1.OutOfBandMessage> | null}
    outParam: void
  }
  'keybase.1.gregorUI.pushState': {
    inParam: {readonly state: Gregor1.State; readonly reason: PushReason}
    outParam: void
  }
  'keybase.1.home.homeDismissAnnouncement': {
    inParam: {readonly i: HomeScreenAnnouncementID}
    outParam: void
  }
  'keybase.1.home.homeGetScreen': {
    inParam: {readonly markViewed: Boolean; readonly numFollowSuggestionsWanted: Int}
    outParam: HomeScreen
  }
  'keybase.1.home.homeMarkViewed': {
    inParam: void
    outParam: void
  }
  'keybase.1.home.homeSkipTodoType': {
    inParam: {readonly t: HomeScreenTodoType}
    outParam: void
  }
  'keybase.1.homeUI.homeUIRefresh': {
    inParam: void
    outParam: void
  }
  'keybase.1.identify.identify2': {
    inParam: {readonly uid: UID; readonly userAssertion: String; readonly reason: IdentifyReason; readonly useDelegateUI: Boolean; readonly alwaysBlock: Boolean; readonly noErrorOnTrackFailure: Boolean; readonly forceRemoteCheck: Boolean; readonly needProofSet: Boolean; readonly allowEmptySelfID: Boolean; readonly noSkipSelf: Boolean; readonly canSuppressUI: Boolean; readonly identifyBehavior: TLFIdentifyBehavior; readonly forceDisplay: Boolean; readonly actLoggedOut: Boolean}
    outParam: Identify2Res
  }
  'keybase.1.identify3.identify3': {
    inParam: {readonly assertion: Identify3Assertion; readonly guiID: Identify3GUIID; readonly ignoreCache: Boolean}
    outParam: void
  }
  'keybase.1.identify3.identify3FollowUser': {
    inParam: {readonly guiID: Identify3GUIID; readonly follow: Boolean}
    outParam: void
  }
  'keybase.1.identify3.identify3IgnoreUser': {
    inParam: {readonly guiID: Identify3GUIID}
    outParam: void
  }
  'keybase.1.identify3Ui.identify3Result': {
    inParam: {readonly guiID: Identify3GUIID; readonly result: Identify3ResultType}
    outParam: void
  }
  'keybase.1.identify3Ui.identify3ShowTracker': {
    inParam: {readonly guiID: Identify3GUIID; readonly assertion: Identify3Assertion; readonly reason: IdentifyReason; readonly forceDisplay?: Boolean}
    outParam: void
  }
  'keybase.1.identify3Ui.identify3TrackerTimedOut': {
    inParam: {readonly guiID: Identify3GUIID}
    outParam: void
  }
  'keybase.1.identify3Ui.identify3UpdateRow': {
    inParam: {readonly row: Identify3Row}
    outParam: void
  }
  'keybase.1.identify3Ui.identify3UpdateUserCard': {
    inParam: {readonly guiID: Identify3GUIID; readonly card: UserCard}
    outParam: void
  }
  'keybase.1.identify3Ui.identify3UserReset': {
    inParam: {readonly guiID: Identify3GUIID}
    outParam: void
  }
  'keybase.1.identifyUi.cancel': {
    inParam: void
    outParam: void
  }
  'keybase.1.identifyUi.confirm': {
    inParam: {readonly outcome: IdentifyOutcome}
    outParam: ConfirmResult
  }
  'keybase.1.identifyUi.delegateIdentifyUI': {
    inParam: void
    outParam: Int
  }
  'keybase.1.identifyUi.dismiss': {
    inParam: {readonly username: String; readonly reason: DismissReason}
    outParam: void
  }
  'keybase.1.identifyUi.displayCryptocurrency': {
    inParam: {readonly c: Cryptocurrency}
    outParam: void
  }
  'keybase.1.identifyUi.displayKey': {
    inParam: {readonly key: IdentifyKey}
    outParam: void
  }
  'keybase.1.identifyUi.displayStellarAccount': {
    inParam: {readonly a: StellarAccount}
    outParam: void
  }
  'keybase.1.identifyUi.displayTLFCreateWithInvite': {
    inParam: {readonly folderName: String; readonly isPrivate: Boolean; readonly assertion: String; readonly socialAssertion: SocialAssertion; readonly inviteLink: String; readonly throttled: Boolean}
    outParam: void
  }
  'keybase.1.identifyUi.displayTrackStatement': {
    inParam: {readonly stmt: String}
    outParam: void
  }
  'keybase.1.identifyUi.displayUserCard': {
    inParam: {readonly card: UserCard}
    outParam: void
  }
  'keybase.1.identifyUi.finish': {
    inParam: void
    outParam: void
  }
  'keybase.1.identifyUi.finishSocialProofCheck': {
    inParam: {readonly rp: RemoteProof; readonly lcr: LinkCheckResult}
    outParam: void
  }
  'keybase.1.identifyUi.finishWebProofCheck': {
    inParam: {readonly rp: RemoteProof; readonly lcr: LinkCheckResult}
    outParam: void
  }
  'keybase.1.identifyUi.launchNetworkChecks': {
    inParam: {readonly identity: Identity; readonly user: User}
    outParam: void
  }
  'keybase.1.identifyUi.reportLastTrack': {
    inParam: {readonly track?: TrackSummary | null}
    outParam: void
  }
  'keybase.1.identifyUi.reportTrackToken': {
    inParam: {readonly trackToken: TrackToken}
    outParam: void
  }
  'keybase.1.identifyUi.start': {
    inParam: {readonly username: String; readonly reason: IdentifyReason; readonly forceDisplay?: Boolean}
    outParam: void
  }
  'keybase.1.install.fuseStatus': {
    inParam: {readonly bundleVersion: String}
    outParam: FuseStatus
  }
  'keybase.1.install.installFuse': {
    inParam: void
    outParam: InstallResult
  }
  'keybase.1.install.installKBFS': {
    inParam: void
    outParam: InstallResult
  }
  'keybase.1.install.uninstallKBFS': {
    inParam: void
    outParam: UninstallResult
  }
  'keybase.1.kbfsMount.GetCurrentMountDir': {
    inParam: void
    outParam: String
  }
  'keybase.1.logUi.log': {
    inParam: {readonly level: LogLevel; readonly text: Text}
    outParam: void
  }
  'keybase.1.login.accountDelete': {
    inParam: void
    outParam: void
  }
  'keybase.1.login.deprovision': {
    inParam: {readonly username: String; readonly doRevoke: Boolean}
    outParam: void
  }
  'keybase.1.login.getConfiguredAccounts': {
    inParam: void
    outParam: Array<ConfiguredAccount> | null
  }
  'keybase.1.login.login': {
    inParam: {readonly deviceType: String; readonly username: String; readonly clientType: ClientType; readonly doUserSwitch?: Boolean; readonly paperKey: String; readonly deviceName: String}
    outParam: void
  }
  'keybase.1.login.logout': {
    inParam: void
    outParam: void
  }
  'keybase.1.login.paperKey': {
    inParam: void
    outParam: void
  }
  'keybase.1.login.paperKeySubmit': {
    inParam: {readonly paperPhrase: String}
    outParam: void
  }
  'keybase.1.loginUi.displayPaperKeyPhrase': {
    inParam: {readonly phrase: String}
    outParam: void
  }
  'keybase.1.loginUi.displayPrimaryPaperKey': {
    inParam: {readonly phrase: String}
    outParam: void
  }
  'keybase.1.loginUi.displayResetProgress': {
    inParam: {readonly text: String}
    outParam: void
  }
  'keybase.1.loginUi.explainDeviceRecovery': {
    inParam: {readonly kind: DeviceType; readonly name: String}
    outParam: void
  }
  'keybase.1.loginUi.getEmailOrUsername': {
    inParam: void
    outParam: String
  }
  'keybase.1.loginUi.promptPassphraseRecovery': {
    inParam: {readonly kind: PassphraseRecoveryPromptType}
    outParam: Bool
  }
  'keybase.1.loginUi.promptResetAccount': {
    inParam: {readonly kind: ResetPromptType}
    outParam: Boolean
  }
  'keybase.1.loginUi.promptRevokePaperKeys': {
    inParam: {readonly device: Device; readonly index: Int}
    outParam: Boolean
  }
  'keybase.1.logsend.prepareLogsend': {
    inParam: void
    outParam: void
  }
  'keybase.1.notifyCtl.setNotifications': {
    inParam: {readonly channels: NotificationChannels}
    outParam: void
  }
  'keybase.1.pgp.pgpKeyGenDefault': {
    inParam: {readonly createUids: PGPCreateUids}
    outParam: void
  }
  'keybase.1.pgp.pgpStorageDismiss': {
    inParam: void
    outParam: void
  }
  'keybase.1.pgpUi.finished': {
    inParam: void
    outParam: void
  }
  'keybase.1.pgpUi.keyGenerated': {
    inParam: {readonly kid: KID; readonly key: KeyInfo}
    outParam: void
  }
  'keybase.1.pgpUi.outputSignatureSuccess': {
    inParam: {readonly fingerprint: String; readonly username: String; readonly signedAt: Time}
    outParam: void
  }
  'keybase.1.pgpUi.outputSignatureSuccessNonKeybase': {
    inParam: {readonly keyID: String; readonly signedAt: Time}
    outParam: void
  }
  'keybase.1.pgpUi.shouldPushPrivate': {
    inParam: {readonly prompt: Boolean}
    outParam: Boolean
  }
  'keybase.1.pprof.logProcessorProfile': {
    inParam: {readonly logDirForMobile: String; readonly profileDurationSeconds: DurationSec}
    outParam: void
  }
  'keybase.1.pprof.logTrace': {
    inParam: {readonly logDirForMobile: String; readonly traceDurationSeconds: DurationSec}
    outParam: void
  }
  'keybase.1.prove.checkProof': {
    inParam: {readonly sigID: SigID}
    outParam: CheckProofStatus
  }
  'keybase.1.prove.startProof': {
    inParam: {readonly service: String; readonly username: String; readonly force: Boolean; readonly promptPosted: Boolean; readonly auto: Boolean; readonly sigVersion?: SigVersion | null}
    outParam: StartProofResult
  }
  'keybase.1.proveUi.checking': {
    inParam: {readonly name: String}
    outParam: void
  }
  'keybase.1.proveUi.continueChecking': {
    inParam: void
    outParam: Boolean
  }
  'keybase.1.proveUi.displayRecheckWarning': {
    inParam: {readonly text: Text}
    outParam: void
  }
  'keybase.1.proveUi.okToCheck': {
    inParam: {readonly name: String; readonly attempt: Int}
    outParam: Boolean
  }
  'keybase.1.proveUi.outputInstructions': {
    inParam: {readonly instructions: Text; readonly proof: String; readonly parameters?: ProveParameters | null}
    outParam: void
  }
  'keybase.1.proveUi.outputPrechecks': {
    inParam: {readonly text: Text}
    outParam: void
  }
  'keybase.1.proveUi.preProofWarning': {
    inParam: {readonly text: Text}
    outParam: Boolean
  }
  'keybase.1.proveUi.promptOverwrite': {
    inParam: {readonly account: String; readonly typ: PromptOverwriteType}
    outParam: Boolean
  }
  'keybase.1.proveUi.promptUsername': {
    inParam: {readonly prompt: String; readonly prevError?: Status | null; readonly parameters?: ProveParameters | null}
    outParam: String
  }
  'keybase.1.provisionUi.DisplayAndPromptSecret': {
    inParam: {readonly secret: Bytes; readonly phrase: String; readonly otherDeviceType: DeviceType; readonly previousErr: String}
    outParam: SecretResponse
  }
  'keybase.1.provisionUi.DisplaySecretExchanged': {
    inParam: void
    outParam: void
  }
  'keybase.1.provisionUi.PromptNewDeviceName': {
    inParam: {readonly existingDevices?: Array<String> | null; readonly errorMessage: String}
    outParam: String
  }
  'keybase.1.provisionUi.ProvisioneeSuccess': {
    inParam: {readonly username: String; readonly deviceName: String}
    outParam: void
  }
  'keybase.1.provisionUi.ProvisionerSuccess': {
    inParam: {readonly deviceName: String; readonly deviceType: String}
    outParam: void
  }
  'keybase.1.provisionUi.chooseDevice': {
    inParam: {readonly devices?: Array<Device> | null; readonly canSelectNoDevice: Boolean}
    outParam: DeviceID
  }
  'keybase.1.provisionUi.chooseDeviceType': {
    inParam: {readonly kind: ChooseType}
    outParam: DeviceType
  }
  'keybase.1.provisionUi.chooseGPGMethod': {
    inParam: {readonly keys?: Array<GPGKey> | null}
    outParam: GPGMethod
  }
  'keybase.1.provisionUi.chooseProvisioningMethod': {
    inParam: {readonly gpgOption: Boolean}
    outParam: ProvisionMethod
  }
  'keybase.1.provisionUi.switchToGPGSignOK': {
    inParam: {readonly key: GPGKey; readonly importError: String}
    outParam: Boolean
  }
  'keybase.1.reachability.checkReachability': {
    inParam: void
    outParam: Reachability
  }
  'keybase.1.reachability.reachabilityChanged': {
    inParam: {readonly reachability: Reachability}
    outParam: void
  }
  'keybase.1.reachability.startReachability': {
    inParam: void
    outParam: Reachability
  }
  'keybase.1.rekey.getRevokeWarning': {
    inParam: {readonly actingDevice: DeviceID; readonly targetDevice: DeviceID}
    outParam: RevokeWarning
  }
  'keybase.1.rekey.rekeyStatusFinish': {
    inParam: void
    outParam: Outcome
  }
  'keybase.1.rekey.showPendingRekeyStatus': {
    inParam: void
    outParam: void
  }
  'keybase.1.rekeyUI.delegateRekeyUI': {
    inParam: void
    outParam: Int
  }
  'keybase.1.rekeyUI.refresh': {
    inParam: {readonly problemSetDevices: ProblemSetDevices}
    outParam: void
  }
  'keybase.1.rekeyUI.rekeySendEvent': {
    inParam: {readonly event: RekeyEvent}
    outParam: void
  }
  'keybase.1.revoke.revokeDevice': {
    inParam: {readonly deviceID: DeviceID; readonly forceSelf: Boolean; readonly forceLast: Boolean}
    outParam: void
  }
  'keybase.1.revoke.revokeKey': {
    inParam: {readonly keyID: KID}
    outParam: void
  }
  'keybase.1.revoke.revokeSigs': {
    inParam: {readonly sigIDQueries?: Array<String> | null}
    outParam: void
  }
  'keybase.1.saltpackUi.saltpackPromptForDecrypt': {
    inParam: {readonly signingKID: KID; readonly sender: SaltpackSender; readonly usedDelegateUI: Boolean}
    outParam: void
  }
  'keybase.1.saltpackUi.saltpackVerifyBadSender': {
    inParam: {readonly signingKID: KID; readonly sender: SaltpackSender}
    outParam: void
  }
  'keybase.1.saltpackUi.saltpackVerifySuccess': {
    inParam: {readonly signingKID: KID; readonly sender: SaltpackSender}
    outParam: void
  }
  'keybase.1.secretUi.getPassphrase': {
    inParam: {readonly pinentry: GUIEntryArg; readonly terminal?: SecretEntryArg | null}
    outParam: GetPassphraseRes
  }
  'keybase.1.signup.checkInvitationCode': {
    inParam: {readonly invitationCode: String}
    outParam: void
  }
  'keybase.1.signup.checkUsernameAvailable': {
    inParam: {readonly username: String}
    outParam: void
  }
  'keybase.1.signup.getInvitationCode': {
    inParam: void
    outParam: String
  }
  'keybase.1.signup.inviteRequest': {
    inParam: {readonly email: String; readonly fullname: String; readonly notes: String}
    outParam: void
  }
  'keybase.1.signup.signup': {
    inParam: {readonly email: String; readonly inviteCode: String; readonly passphrase: String; readonly username: String; readonly deviceName: String; readonly deviceType: DeviceType; readonly storeSecret: Boolean; readonly skipMail: Boolean; readonly genPGPBatch: Boolean; readonly genPaper: Boolean; readonly randomPw: Boolean}
    outParam: SignupRes
  }
  'keybase.1.streamUi.close': {
    inParam: {readonly s: Stream}
    outParam: void
  }
  'keybase.1.streamUi.read': {
    inParam: {readonly s: Stream; readonly sz: Int}
    outParam: Bytes
  }
  'keybase.1.streamUi.reset': {
    inParam: {readonly s: Stream}
    outParam: void
  }
  'keybase.1.streamUi.write': {
    inParam: {readonly s: Stream; readonly buf: Bytes}
    outParam: Int
  }
  'keybase.1.teams.canUserPerform': {
    inParam: {readonly name: String}
    outParam: TeamOperation
  }
  'keybase.1.teams.getTarsDisabled': {
    inParam: {readonly name: String}
    outParam: Boolean
  }
  'keybase.1.teams.getTeamAndMemberShowcase': {
    inParam: {readonly name: String}
    outParam: TeamAndMemberShowcase
  }
  'keybase.1.teams.setTarsDisabled': {
    inParam: {readonly name: String; readonly disabled: Boolean}
    outParam: void
  }
  'keybase.1.teams.setTeamMemberShowcase': {
    inParam: {readonly name: String; readonly isShowcased: Boolean}
    outParam: void
  }
  'keybase.1.teams.setTeamShowcase': {
    inParam: {readonly name: String; readonly isShowcased?: Boolean | null; readonly description?: String | null; readonly anyMemberShowcase?: Boolean | null}
    outParam: void
  }
  'keybase.1.teams.teamAcceptInviteOrRequestAccess': {
    inParam: {readonly tokenOrName: String}
    outParam: TeamAcceptOrRequestResult
  }
  'keybase.1.teams.teamAddEmailsBulk': {
    inParam: {readonly name: String; readonly emails: String; readonly role: TeamRole}
    outParam: BulkRes
  }
  'keybase.1.teams.teamAddMember': {
    inParam: {readonly name: String; readonly email: String; readonly username: String; readonly role: TeamRole; readonly sendChatNotification: Boolean}
    outParam: TeamAddMemberResult
  }
  'keybase.1.teams.teamAddMembers': {
    inParam: {readonly name: String; readonly assertions?: Array<String> | null; readonly role: TeamRole; readonly sendChatNotification: Boolean}
    outParam: void
  }
  'keybase.1.teams.teamCreate': {
    inParam: {readonly name: String; readonly joinSubteam: Boolean}
    outParam: TeamCreateResult
  }
  'keybase.1.teams.teamCreateSeitanTokenV2': {
    inParam: {readonly name: String; readonly role: TeamRole; readonly label: SeitanKeyLabel}
    outParam: SeitanIKeyV2
  }
  'keybase.1.teams.teamEditMember': {
    inParam: {readonly name: String; readonly username: String; readonly role: TeamRole}
    outParam: void
  }
  'keybase.1.teams.teamGet': {
    inParam: {readonly name: String}
    outParam: TeamDetails
  }
  'keybase.1.teams.teamGetMembers': {
    inParam: {readonly name: String}
    outParam: TeamMembersDetails
  }
  'keybase.1.teams.teamGetSubteams': {
    inParam: {readonly name: TeamName}
    outParam: SubteamListResult
  }
  'keybase.1.teams.teamIgnoreRequest': {
    inParam: {readonly name: String; readonly username: String}
    outParam: void
  }
  'keybase.1.teams.teamLeave': {
    inParam: {readonly name: String; readonly permanent: Boolean}
    outParam: void
  }
  'keybase.1.teams.teamListMyAccessRequests': {
    inParam: {readonly teamName?: String | null}
    outParam: Array<TeamName> | null
  }
  'keybase.1.teams.teamListRequests': {
    inParam: {readonly teamName?: String | null}
    outParam: Array<TeamJoinRequest> | null
  }
  'keybase.1.teams.teamListUnverified': {
    inParam: {readonly userAssertion: String; readonly includeImplicitTeams: Boolean}
    outParam: AnnotatedTeamList
  }
  'keybase.1.teams.teamProfileAddList': {
    inParam: {readonly username: String}
    outParam: Array<TeamProfileAddEntry> | null
  }
  'keybase.1.teams.teamReAddMemberAfterReset': {
    inParam: {readonly id: TeamID; readonly username: String}
    outParam: void
  }
  'keybase.1.teams.teamRemoveMember': {
    inParam: {readonly name: String; readonly username: String; readonly email: String; readonly inviteID: TeamInviteID}
    outParam: void
  }
  'keybase.1.teams.teamRename': {
    inParam: {readonly prevName: TeamName; readonly newName: TeamName}
    outParam: void
  }
  'keybase.1.teams.teamSetSettings': {
    inParam: {readonly name: String; readonly settings: TeamSettings}
    outParam: void
  }
  'keybase.1.teams.uploadTeamAvatar': {
    inParam: {readonly teamname: String; readonly filename: String; readonly crop?: ImageCropRect | null; readonly sendChatNotification: Boolean}
    outParam: void
  }
  'keybase.1.teamsUi.confirmRootTeamDelete': {
    inParam: {readonly teamName: String}
    outParam: Boolean
  }
  'keybase.1.teamsUi.confirmSubteamDelete': {
    inParam: {readonly teamName: String}
    outParam: Boolean
  }
  'keybase.1.track.checkTracking': {
    inParam: void
    outParam: void
  }
  'keybase.1.track.dismissWithToken': {
    inParam: {readonly trackToken: TrackToken}
    outParam: void
  }
  'keybase.1.track.trackWithToken': {
    inParam: {readonly trackToken: TrackToken; readonly options: TrackOptions}
    outParam: void
  }
  'keybase.1.track.untrack': {
    inParam: {readonly username: String}
    outParam: void
  }
  'keybase.1.ui.promptYesNo': {
    inParam: {readonly text: Text; readonly promptDefault: PromptDefault}
    outParam: Boolean
  }
  'keybase.1.user.canLogout': {
    inParam: void
    outParam: CanLogoutRes
  }
  'keybase.1.user.interestingPeople': {
    inParam: {readonly maxUsers: Int}
    outParam: Array<InterestingPerson> | null
  }
  'keybase.1.user.listTrackers2': {
    inParam: {readonly assertion: String; readonly reverse: Boolean}
    outParam: UserSummary2Set
  }
  'keybase.1.user.loadHasRandomPw': {
    inParam: {readonly forceRepoll: Boolean}
    outParam: Boolean
  }
  'keybase.1.user.loadMySettings': {
    inParam: void
    outParam: UserSettings
  }
  'keybase.1.user.profileEdit': {
    inParam: {readonly fullName: String; readonly location: String; readonly bio: String}
    outParam: void
  }
  'keybase.1.user.proofSuggestions': {
    inParam: void
    outParam: ProofSuggestionsRes
  }
  'keybase.1.user.uploadUserAvatar': {
    inParam: {readonly filename: String; readonly crop?: ImageCropRect | null}
    outParam: void
  }
}

export enum appStateMobileAppState {
  foreground = 0,
  background = 1,
  inactive = 2,
  backgroundactive = 3,
}

export enum auditBoxAuditAttemptResult {
  failureRetryable = 0,
  failureMaliciousServer = 1,
  okVerified = 2,
  okNotAttemptedRole = 3,
  okNotAttemptedOpenteam = 4,
  okNotAttemptedSubteam = 5,
}

export enum backendCommonBlockType {
  data = 0,
  md = 1,
  git = 2,
}

export enum blockBlockStatus {
  unknown = 0,
  live = 1,
  archived = 2,
}

export enum commonClientType {
  none = 0,
  cli = 1,
  guiMain = 2,
  kbfs = 3,
  guiHelper = 4,
}

export enum commonDeviceType {
  desktop = 0,
  mobile = 1,
}

export enum commonFullNamePackageVersion {
  v0 = 0,
  v1 = 1,
  v2 = 2,
}

export enum commonIdentityVisibility {
  private = 0,
  public = 1,
}

export enum commonLogLevel {
  none = 0,
  debug = 1,
  info = 2,
  notice = 3,
  warn = 4,
  error = 5,
  critical = 6,
  fatal = 7,
}

export enum commonMerkleTreeID {
  master = 0,
  kbfsPublic = 1,
  kbfsPrivate = 2,
  kbfsPrivateteam = 3,
}

export enum commonOfflineAvailability {
  none = 0,
  bestEffort = 1,
}

export enum commonSeqType {
  none = 0,
  public = 1,
  private = 2,
  semiprivate = 3,
}

export enum commonTLFVisibility {
  any = 0,
  public = 1,
  private = 2,
}

export enum commonTeamType {
  none = 0,
  legacy = 1,
  modern = 2,
}

export enum commonUserOrTeamResult {
  user = 1,
  team = 2,
}

export enum configForkType {
  none = 0,
  auto = 1,
  watchdog = 2,
  launchd = 3,
  systemd = 4,
}

export enum configUpdateInfoStatus {
  upToDate = 0,
  needUpdate = 1,
  criticallyOutOfDate = 2,
}

export enum configUpdateInfoStatus2 {
  ok = 0,
  suggested = 1,
  critical = 2,
}

export enum constantsStatusCode {
  scok = 0,
  scinputerror = 100,
  scloginrequired = 201,
  scbadsession = 202,
  scbadloginusernotfound = 203,
  scbadloginpassword = 204,
  scnotfound = 205,
  scthrottlecontrol = 210,
  scdeleted = 216,
  scgeneric = 218,
  scalreadyloggedin = 235,
  scexists = 230,
  sccanceled = 237,
  scinputcanceled = 239,
  scbadusername = 243,
  scoffline = 267,
  screloginrequired = 274,
  scresolutionfailed = 275,
  scprofilenotpublic = 276,
  scidentifyfailed = 277,
  sctrackingbroke = 278,
  scwrongcryptoformat = 279,
  scdecryptionerror = 280,
  scinvalidaddress = 281,
  scnosession = 283,
  scaccountreset = 290,
  scidentifiesfailed = 295,
  scnospaceondevice = 297,
  scmerkleclienterror = 299,
  scbademail = 472,
  scratelimit = 602,
  scbadsignupusernametaken = 701,
  scbadinvitationcode = 707,
  scfeatureflag = 712,
  scmissingresult = 801,
  sckeynotfound = 901,
  sckeycorrupted = 905,
  sckeyinuse = 907,
  sckeybadgen = 913,
  sckeynosecret = 914,
  sckeybaduids = 915,
  sckeynoactive = 916,
  sckeynosig = 917,
  sckeybadsig = 918,
  sckeybadeldest = 919,
  sckeynoeldest = 920,
  sckeyduplicateupdate = 921,
  scsibkeyalreadyexists = 922,
  scdecryptionkeynotfound = 924,
  sckeynopgpencryption = 927,
  sckeynonaclencryption = 928,
  sckeysyncedpgpnotfound = 929,
  sckeynomatchinggpg = 930,
  sckeyrevoked = 931,
  scsigcannotverify = 1002,
  scsigwrongkey = 1008,
  scsigoldseqno = 1010,
  scsigcreationdisallowed = 1016,
  scbadtracksession = 1301,
  scdevicebadname = 1404,
  scdevicenameinuse = 1408,
  scdevicenotfound = 1409,
  scdevicemismatch = 1410,
  scdevicerequired = 1411,
  scdeviceprevprovisioned = 1413,
  scdevicenoprovision = 1414,
  scdeviceprovisionviadevice = 1415,
  screvokecurrentdevice = 1416,
  screvokelastdevice = 1417,
  scdeviceprovisionoffline = 1418,
  screvokelastdevicepgp = 1419,
  scstreamexists = 1501,
  scstreamnotfound = 1502,
  scstreamwrongkind = 1503,
  scstreameof = 1504,
  scgenericapierror = 1600,
  scapinetworkerror = 1601,
  sctimeout = 1602,
  scprooferror = 1701,
  scidentificationexpired = 1702,
  scselfnotfound = 1703,
  scbadkexphrase = 1704,
  scnouidelegation = 1705,
  scnoui = 1706,
  scgpgunavailable = 1707,
  scinvalidversionerror = 1800,
  scoldversionerror = 1801,
  scinvalidlocationerror = 1802,
  scservicestatuserror = 1803,
  scinstallerror = 1804,
  scloadkexterror = 1810,
  scloadkextpermerror = 1811,
  scgitinternal = 2300,
  scgitrepoalreadyexists = 2301,
  scgitinvalidreponame = 2302,
  scgitcannotdelete = 2303,
  scgitrepodoesntexist = 2304,
  scloginstatetimeout = 2400,
  scchatinternal = 2500,
  scchatratelimit = 2501,
  scchatconvexists = 2502,
  scchatunknowntlfid = 2503,
  scchatnotinconv = 2504,
  scchatbadmsg = 2505,
  scchatbroadcast = 2506,
  scchatalreadysuperseded = 2507,
  scchatalreadydeleted = 2508,
  scchattlffinalized = 2509,
  scchatcollision = 2510,
  scidentifysummaryerror = 2511,
  scneedselfrekey = 2512,
  scneedotherrekey = 2513,
  scchatmessagecollision = 2514,
  scchatduplicatemessage = 2515,
  scchatclienterror = 2516,
  scchatnotinteam = 2517,
  scchatstalepreviousstate = 2518,
  scchatephemeralretentionpolicyviolatederror = 2519,
  scteambadmembership = 2604,
  scteamselfnotowner = 2607,
  scteamnotfound = 2614,
  scteamexists = 2619,
  scteamreaderror = 2623,
  scteamwritepermdenied = 2625,
  scnoop = 2638,
  scteaminvitebadtoken = 2646,
  scteamtarduplicate = 2663,
  scteamtarnotfound = 2664,
  scteammemberexists = 2665,
  scteamnotreleased = 2666,
  scteampermanentlyleft = 2667,
  scteamneedrootid = 2668,
  scteamhaslivechildren = 2669,
  scteamdeleteerror = 2670,
  scteambadrootteam = 2671,
  scteamnameconflictswithuser = 2672,
  scteamdeletenouppointer = 2673,
  scteamneedowner = 2674,
  scteamnoownerallowed = 2675,
  scteamimplicitnononsbs = 2676,
  scteamimplicitbadhash = 2677,
  scteamimplicitbadname = 2678,
  scteamimplicitclash = 2679,
  scteamimplicitduplicate = 2680,
  scteamimplicitbadop = 2681,
  scteamimplicitbadrole = 2682,
  scteamimplicitnotfound = 2683,
  scteambadadminseqnotype = 2684,
  scteamimplicitbadadd = 2685,
  scteamimplicitbadremove = 2686,
  scteaminvitetokenreused = 2696,
  scteamkeymasknotfound = 2697,
  scteambanned = 2702,
  scteaminvalidban = 2703,
  scteamshowcasepermdenied = 2711,
  scteamprovisionalcankey = 2721,
  scteamprovisionalcannotkey = 2722,
  scteamftloutdated = 2736,
  scephemeralkeybadgeneration = 2900,
  scephemeralkeyunexpectedbox = 2901,
  scephemeralkeymissingbox = 2902,
  scephemeralkeywrongnumberofkeys = 2903,
  scephemeralkeymismatchedkey = 2904,
  scephemeralpairwisemacsmissinguids = 2905,
  scephemeraldeviceafterek = 2906,
  scephemeralmemberafterek = 2907,
  scephemeraldevicestale = 2908,
  scephemeraluserstale = 2909,
  scstellarerror = 3100,
  scstellarbadinput = 3101,
  scstellarwrongrevision = 3102,
  scstellarmissingbundle = 3103,
  scstellarbadpuk = 3104,
  scstellarmissingaccount = 3105,
  scstellarbadprev = 3106,
  scstellarwrongprimary = 3107,
  scstellarunsupportedcurrency = 3108,
  scstellarneeddisclaimer = 3109,
  scstellardevicenotmobile = 3110,
  scstellarmobileonlypurgatory = 3111,
  scstellarincompatibleversion = 3112,
  scnistwrongsize = 3201,
  scnistbadmode = 3202,
  scnisthashwrongsize = 3203,
  scnistsigwrongsize = 3204,
  scnistsigbadinput = 3205,
  scnistsigbaduid = 3206,
  scnistsigbaddeviceid = 3207,
  scnistsigbadnonce = 3208,
  scnistnosigorhash = 3209,
  scnistexpired = 3210,
  scnistsigrevoked = 3211,
  scnistkeyrevoked = 3212,
  scnistuserdeleted = 3213,
  scnistnodevice = 3214,
  scnistsigcannotVerify = 3215,
  scnistreplay = 3216,
  scnistsigbadlifetime = 3217,
  scnistnotfound = 3218,
  scnistbadclock = 3219,
  scnistsigbadctime = 3220,
  scbadsignupusernamedeleted = 3221,
  scnopaperkeys = 3605,
}

export enum ctlDbType {
  main = 0,
  chat = 1,
}

export enum ctlExitCode {
  ok = 0,
  notok = 2,
  restart = 4,
}

export enum favoriteConflictStateType {
  automaticresolving = 0,
  manualresolvingserverview = 1,
  manualresolvinglocalview = 2,
}

export enum favoriteFolderConflictType {
  none = 0,
  inConflict = 1,
  inConflictAndStuck = 2,
}

export enum favoriteFolderType {
  unknown = 0,
  private = 1,
  public = 2,
  team = 3,
}

export enum gitGitLocalMetadataVersion {
  v1 = 1,
}

export enum gitGitPushType {
  default = 0,
  createrepo = 1,
  renamerepo = 3,
}

export enum gitGitRepoResultState {
  err = 0,
  ok = 1,
}

export enum gregorUIPushReason {
  none = 0,
  reconnected = 1,
  newData = 2,
}

export enum homeAppLinkType {
  none = 0,
  people = 1,
  chat = 2,
  files = 3,
  wallet = 4,
  git = 5,
  devices = 6,
  settings = 7,
  teams = 8,
}

export enum homeHomeScreenItemType {
  todo = 1,
  people = 2,
  announcement = 3,
}

export enum homeHomeScreenPeopleNotificationType {
  followed = 1,
  followedMulti = 2,
}

export enum homeHomeScreenTodoType {
  none = 0,
  bio = 1,
  proof = 2,
  device = 3,
  follow = 4,
  chat = 5,
  paperkey = 6,
  team = 7,
  folder = 8,
  gitRepo = 9,
  teamShowcase = 10,
  avatarUser = 11,
  avatarTeam = 12,
  annoncementPlaceholder = 10000,
}

export enum identify3UiIdentify3ResultType {
  ok = 0,
  broken = 1,
  needsUpgrade = 2,
  canceled = 3,
}

export enum identify3UiIdentify3RowColor {
  blue = 1,
  red = 2,
  black = 3,
  green = 4,
  gray = 5,
  yellow = 6,
  orange = 7,
}

export enum identify3UiIdentify3RowState {
  checking = 1,
  valid = 2,
  error = 3,
  warning = 4,
  revoked = 5,
}

export enum identifyCommonIdentifyReasonType {
  none = 0,
  id = 1,
  track = 2,
  encrypt = 3,
  decrypt = 4,
  verify = 5,
  resource = 6,
  background = 7,
}

export enum identifyCommonTrackDiffType {
  none = 0,
  error = 1,
  clash = 2,
  revoked = 3,
  upgraded = 4,
  new = 5,
  remoteFail = 6,
  remoteWorking = 7,
  remoteChanged = 8,
  newEldest = 9,
  noneViaTemporary = 10,
}

export enum identifyCommonTrackStatus {
  newOk = 1,
  newZeroProofs = 2,
  newFailProofs = 3,
  updateBrokenFailedProofs = 4,
  updateNewProofs = 5,
  updateOk = 6,
  updateBrokenRevoked = 7,
}

export enum identifyUiCheckResultFreshness {
  fresh = 0,
  aged = 1,
  rancid = 2,
}

export enum identifyUiDismissReasonType {
  none = 0,
  handledElsewhere = 1,
}

export enum installInstallAction {
  unknown = 0,
  none = 1,
  upgrade = 2,
  reinstall = 3,
  install = 4,
}

export enum installInstallStatus {
  unknown = 0,
  error = 1,
  notInstalled = 2,
  installed = 4,
}

export enum kbfsCommonFSErrorType {
  accessDenied = 0,
  userNotFound = 1,
  revokedDataDetected = 2,
  notLoggedIn = 3,
  timeout = 4,
  rekeyNeeded = 5,
  badFolder = 6,
  notImplemented = 7,
  oldVersion = 8,
  overQuota = 9,
  noSigChain = 10,
  tooManyFolders = 11,
  exdevNotSupported = 12,
  diskLimitReached = 13,
  diskCacheErrorLogSend = 14,
  offlineArchived = 15,
  offlineUnsynced = 16,
}

export enum kbfsCommonFSNotificationType {
  encrypting = 0,
  decrypting = 1,
  signing = 2,
  verifying = 3,
  rekeying = 4,
  connection = 5,
  mdReadSuccess = 6,
  fileCreated = 7,
  fileModified = 8,
  fileDeleted = 9,
  fileRenamed = 10,
  initialized = 11,
  syncConfigChanged = 12,
}

export enum kbfsCommonFSStatusCode {
  start = 0,
  finish = 1,
  error = 2,
}

export enum loginUiPassphraseRecoveryPromptType {
  encryptedPgpKeys = 0,
}

export enum loginUiResetPromptType {
  complete = 0,
  enterNoDevices = 1,
  enterForgotPw = 2,
}

export enum notifyTeamAvatarUpdateType {
  none = 0,
  user = 1,
  team = 2,
}

export enum passphraseCommonPassphraseType {
  none = 0,
  paperKey = 1,
  passPhrase = 2,
  verifyPassPhrase = 3,
}

export enum pgpSignMode {
  attached = 0,
  detached = 1,
  clear = 2,
}

export enum processFileType {
  unknown = 0,
  directory = 1,
  file = 2,
}

export enum proveCommonProofState {
  none = 0,
  ok = 1,
  tempFailure = 2,
  permFailure = 3,
  looking = 4,
  superseded = 5,
  posted = 6,
  revoked = 7,
  deleted = 8,
  unknownType = 9,
  sigHintMissing = 10,
  unchecked = 11,
}

export enum proveCommonProofStatus {
  none = 0,
  ok = 1,
  local = 2,
  found = 3,
  baseError = 100,
  hostUnreachable = 101,
  permissionDenied = 103,
  failedParse = 106,
  dnsError = 107,
  authFailed = 108,
  http429 = 129,
  http500 = 150,
  timeout = 160,
  internalError = 170,
  unchecked = 171,
  missingPvl = 172,
  baseHardError = 200,
  notFound = 201,
  contentFailure = 202,
  badUsername = 203,
  badRemoteId = 204,
  textNotFound = 205,
  badArgs = 206,
  contentMissing = 207,
  titleNotFound = 208,
  serviceError = 209,
  torSkipped = 210,
  torIncompatible = 211,
  http300 = 230,
  http400 = 240,
  httpOther = 260,
  emptyJson = 270,
  deleted = 301,
  serviceDead = 302,
  badSignature = 303,
  badApiUrl = 304,
  unknownType = 305,
  noHint = 306,
  badHintText = 307,
  invalidPvl = 308,
}

export enum proveCommonProofType {
  none = 0,
  keybase = 1,
  twitter = 2,
  github = 3,
  reddit = 4,
  coinbase = 5,
  hackernews = 6,
  facebook = 8,
  genericSocial = 9,
  genericWebSite = 1000,
  dns = 1001,
  pgp = 1002,
  rooter = 100001,
}

export enum proveUiPromptOverwriteType {
  social = 0,
  site = 1,
}

export enum provisionUiChooseType {
  existingDevice = 0,
  newDevice = 1,
}

export enum provisionUiGPGMethod {
  gpgNone = 0,
  gpgImport = 1,
  gpgSign = 2,
}

export enum provisionUiProvisionMethod {
  device = 0,
  paperKey = 1,
  passphrase = 2,
  gpgImport = 3,
  gpgSign = 4,
}

export enum reachabilityReachable {
  unknown = 0,
  yes = 1,
  no = 2,
}

export enum rekeyOutcome {
  none = 0,
  fixed = 1,
  ignored = 2,
}

export enum rekeyUIRekeyEventType {
  none = 0,
  notLoggedIn = 1,
  apiError = 2,
  noProblems = 3,
  loadMeError = 4,
  currentDeviceCanRekey = 5,
  deviceLoadError = 6,
  harass = 7,
  noGregorMessages = 8,
}

export enum resetResetType {
  none = 0,
  reset = 1,
  delete = 2,
}

export enum runtimeRuntimeGroup {
  unknown = 0,
  linuxlike = 1,
  darwinlike = 2,
  windowslike = 3,
}

export enum saltpackAuthenticityType {
  signed = 0,
  repudiable = 1,
  anonymous = 2,
}

export enum saltpackUiSaltpackSenderType {
  notTracked = 0,
  unknown = 1,
  anonymous = 2,
  trackingBroke = 3,
  trackingOk = 4,
  self = 5,
  revoked = 6,
  expired = 7,
}

export enum simpleFSAsyncOps {
  list = 0,
  listRecursive = 1,
  read = 2,
  write = 3,
  copy = 4,
  move = 5,
  remove = 6,
  listRecursiveToDepth = 7,
  getRevisions = 8,
}

export enum simpleFSDirentType {
  file = 0,
  dir = 1,
  sym = 2,
  exec = 3,
}

export enum simpleFSFolderSyncMode {
  disabled = 0,
  enabled = 1,
  partial = 2,
}

export enum simpleFSKBFSArchivedType {
  revision = 0,
  time = 1,
  timeString = 2,
  relTimeString = 3,
}

export enum simpleFSListFilter {
  noFilter = 0,
  filterAllHidden = 1,
  filterSystemHidden = 2,
}

export enum simpleFSOpenFlags {
  read = 0,
  replace = 1,
  existing = 2,
  write = 4,
  append = 8,
  directory = 16,
}

export enum simpleFSPathType {
  local = 0,
  kbfs = 1,
  kbfsArchived = 2,
}

export enum simpleFSPrefetchStatus {
  notStarted = 0,
  inProgress = 1,
  complete = 2,
}

export enum simpleFSRevisionSpanType {
  default = 0,
  lastFive = 1,
}

export enum teamsAuditVersion {
  v0 = 0,
  v1 = 1,
  v2 = 2,
  v3 = 3,
}

export enum teamsSeitanKeyAndLabelVersion {
  v1 = 1,
  v2 = 2,
}

export enum teamsSeitanKeyLabelType {
  sms = 1,
}

export enum teamsTeamApplication {
  kbfs = 1,
  chat = 2,
  saltpack = 3,
  gitMetadata = 4,
  seitanInviteToken = 5,
  stellarRelay = 6,
}

export enum teamsTeamInviteCategory {
  none = 0,
  unknown = 1,
  keybase = 2,
  email = 3,
  sbs = 4,
  seitan = 5,
  phone = 6,
}

export enum teamsTeamMemberStatus {
  active = 0,
  reset = 1,
  deleted = 2,
}

export enum teamsTeamRole {
  none = 0,
  reader = 1,
  writer = 2,
  admin = 3,
  owner = 4,
}

export enum teamsTeamStatus {
  none = 0,
  live = 1,
  deleted = 2,
  abandoned = 3,
}

export enum tlfKeysTLFIdentifyBehavior {
  unset = 0,
  chatCli = 1,
  chatGui = 2,
  removedAndUnused = 3,
  kbfsRekey = 4,
  kbfsQr = 5,
  chatSkip = 6,
  saltpack = 7,
  cli = 8,
  gui = 9,
  defaultKbfs = 10,
  kbfsChat = 11,
  resolveAndCheck = 12,
  guiProfile = 13,
  kbfsInit = 14,
}

export enum uPKKeyType {
  none = 0,
  nacl = 1,
  pgp = 2,
}

export enum uPKUPAKVersion {
  v1 = 1,
  v2 = 2,
}

export enum uPKUPK2MinorVersion {
  v0 = 0,
  v1 = 1,
  v2 = 2,
  v3 = 3,
  v4 = 4,
  v5 = 5,
  v6 = 6,
}

export enum uPKUPKLiteMinorVersion {
  v0 = 0,
}

export enum uiPromptDefault {
  none = 0,
  yes = 1,
  no = 2,
}
export type APIRes = {readonly status: String; readonly body: String; readonly httpStatus: Int; readonly appStatus: String}
export type AllProvisionedUsernames = {readonly defaultUsername: String; readonly provisionedUsernames?: Array<String> | null; readonly hasProvisionedUser: Boolean}
export type AnnotatedMemberInfo = {readonly userID: UID; readonly teamID: TeamID; readonly username: String; readonly fullName: String; readonly fqName: String; readonly isImplicitTeam: Boolean; readonly impTeamDisplayName: String; readonly isOpenTeam: Boolean; readonly role: TeamRole; readonly implicit?: ImplicitRole | null; readonly needsPUK: Boolean; readonly memberCount: Int; readonly eldestSeqno: Seqno; readonly allowProfilePromote: Boolean; readonly isMemberShowcased: Boolean; readonly status: TeamMemberStatus}
export type AnnotatedTeamInvite = {readonly role: TeamRole; readonly id: TeamInviteID; readonly type: TeamInviteType; readonly name: TeamInviteName; readonly uv: UserVersion; readonly inviter: UserVersion; readonly inviterUsername: String; readonly teamName: String; readonly status: TeamMemberStatus}
export type AnnotatedTeamList = {readonly teams?: Array<AnnotatedMemberInfo> | null; readonly annotatedActiveInvites: {[key: string]: AnnotatedTeamInvite}}
export type AppLinkType =
  | 0 // NONE_0
  | 1 // PEOPLE_1
  | 2 // CHAT_2
  | 3 // FILES_3
  | 4 // WALLET_4
  | 5 // GIT_5
  | 6 // DEVICES_6
  | 7 // SETTINGS_7
  | 8 // TEAMS_8

export type AsyncOps =
  | 0 // LIST_0
  | 1 // LIST_RECURSIVE_1
  | 2 // READ_2
  | 3 // WRITE_3
  | 4 // COPY_4
  | 5 // MOVE_5
  | 6 // REMOVE_6
  | 7 // LIST_RECURSIVE_TO_DEPTH_7
  | 8 // GET_REVISIONS_8

export type Audit = {readonly time: Time; readonly mms: /* maxMerkleSeqno */ Seqno; readonly mcs: /* maxChainSeqno */ Seqno; readonly mmp: /* maxMerkleProbe */ Seqno}
export type AuditHistory = {readonly ID: TeamID; readonly public: Boolean; readonly priorMerkleSeqno: Seqno; readonly version: AuditVersion; readonly audits?: Array<Audit> | null; readonly preProbes: {[key: string]: Probe}; readonly postProbes: {[key: string]: Probe}; readonly tails: {[key: string]: LinkID}}
export type AuditVersion =
  | 0 // V0_0
  | 1 // V1_1
  | 2 // V2_2
  | 3 // V3_3

export type AuthenticityType =
  | 0 // SIGNED_0
  | 1 // REPUDIABLE_1
  | 2 // ANONYMOUS_2

export type AvatarClearCacheMsg = {readonly name: String; readonly formats?: Array<AvatarFormat> | null; readonly typ: AvatarUpdateType}
export type AvatarFormat = String
export type AvatarUpdateType =
  | 0 // NONE_0
  | 1 // USER_1
  | 2 // TEAM_2

export type AvatarUrl = String
export type BadgeConversationInfo = {readonly convID: ChatConversationID; readonly badgeCounts: {[key: string]: Int}; readonly unreadMessages: Int}
export type BadgeState = {readonly newTlfs: Int; readonly rekeysNeeded: Int; readonly newFollowers: Int; readonly inboxVers: Int; readonly homeTodoItems: Int; readonly newDevices?: Array<DeviceID> | null; readonly revokedDevices?: Array<DeviceID> | null; readonly conversations?: Array<BadgeConversationInfo> | null; readonly newGitRepoGlobalUniqueIDs?: Array<String> | null; readonly newTeamNames?: Array<String> | null; readonly deletedTeams?: Array<DeletedTeamInfo> | null; readonly newTeamAccessRequests?: Array<String> | null; readonly teamsWithResetUsers?: Array<TeamMemberOutReset> | null; readonly unreadWalletAccounts?: Array<WalletAccountInfo> | null; readonly resetState: ResetState}
export type BinaryKID = Bytes
export type BlockIdCombo = {readonly blockHash: String; readonly chargedTo: UserOrTeamID; readonly blockType: BlockType}
export type BlockIdCount = {readonly id: BlockIdCombo; readonly liveCount: Int}
export type BlockPingResponse = {}
export type BlockRefNonce = string | null
export type BlockReference = {readonly bid: BlockIdCombo; readonly nonce: BlockRefNonce; readonly chargedTo: UserOrTeamID}
export type BlockReferenceCount = {readonly ref: BlockReference; readonly liveCount: Int}
export type BlockStatus =
  | 0 // UNKNOWN_0
  | 1 // LIVE_1
  | 2 // ARCHIVED_2

export type BlockType =
  | 0 // DATA_0
  | 1 // MD_1
  | 2 // GIT_2

export type BootstrapStatus = {readonly registered: Boolean; readonly loggedIn: Boolean; readonly uid: UID; readonly username: String; readonly deviceID: DeviceID; readonly deviceName: String; readonly fullname: FullName; readonly following?: Array<String> | null; readonly followers?: Array<String> | null; readonly userReacjis: UserReacjis}
export type BoxAuditAttempt = {readonly ctime: UnixTime; readonly error?: String | null; readonly result: BoxAuditAttemptResult; readonly generation?: PerTeamKeyGeneration | null; readonly rotated: Boolean}
export type BoxAuditAttemptResult =
  | 0 // FAILURE_RETRYABLE_0
  | 1 // FAILURE_MALICIOUS_SERVER_1
  | 2 // OK_VERIFIED_2
  | 3 // OK_NOT_ATTEMPTED_ROLE_3
  | 4 // OK_NOT_ATTEMPTED_OPENTEAM_4
  | 5 // OK_NOT_ATTEMPTED_SUBTEAM_5

export type BoxNonce = string | null
export type BoxPublicKey = string | null
export type BoxSummaryHash = String
export type BulkRes = {readonly invited?: Array<String> | null; readonly alreadyInvited?: Array<String> | null; readonly malformed?: Array<String> | null}
export type Bytes32 = string | null
export type CanLogoutRes = {readonly canLogout: Boolean; readonly reason: String; readonly setPassphrase: Boolean}
export type CanonicalTLFNameAndIDWithBreaks = {readonly tlfID: TLFID; readonly CanonicalName: CanonicalTlfName; readonly breaks: TLFBreak}
export type CanonicalTlfName = String
export type ChallengeInfo = {readonly now: Long; readonly challenge: String}
export type ChatConversationID = Bytes
export type CheckProofStatus = {readonly found: Boolean; readonly status: ProofStatus; readonly proofText: String; readonly state: ProofState}
export type CheckResult = {readonly proofResult: ProofResult; readonly time: Time; readonly freshness: CheckResultFreshness}
export type CheckResultFreshness =
  | 0 // FRESH_0
  | 1 // AGED_1
  | 2 // RANCID_2

export type ChooseType =
  | 0 // EXISTING_DEVICE_0
  | 1 // NEW_DEVICE_1

export type CiphertextBundle = {readonly kid: KID; readonly ciphertext: EncryptedBytes32; readonly nonce: BoxNonce; readonly publicKey: BoxPublicKey}
export type ClientDetails = {readonly pid: Int; readonly clientType: ClientType; readonly argv?: Array<String> | null; readonly desc: String; readonly version: String}
export type ClientStatus = {readonly details: ClientDetails; readonly connectionID: Int; readonly notificationChannels: NotificationChannels}
export type ClientType =
  | 0 // NONE_0
  | 1 // CLI_1
  | 2 // GUI_MAIN_2
  | 3 // KBFS_3
  | 4 // GUI_HELPER_4

export type CompatibilityTeamID = {typ: 1; legacy: TLFID | null} | {typ: 2; modern: TeamID | null}
export type ComponentResult = {readonly name: String; readonly status: Status; readonly exitCode: Int}
export type Config = {readonly serverURI: String; readonly socketFile: String; readonly label: String; readonly runMode: String; readonly gpgExists: Boolean; readonly gpgPath: String; readonly version: String; readonly path: String; readonly binaryRealpath: String; readonly configPath: String; readonly versionShort: String; readonly versionFull: String; readonly isAutoForked: Boolean; readonly forkType: ForkType}
export type ConfigValue = {readonly isNull: Boolean; readonly b?: Boolean | null; readonly i?: Int | null; readonly s?: String | null; readonly o?: String | null}
export type ConfiguredAccount = {readonly username: String; readonly hasStoredSecret: Boolean}
export type ConfirmResult = {readonly identityConfirmed: Boolean; readonly remoteConfirmed: Boolean; readonly expiringLocal: Boolean; readonly autoConfirmed: Boolean}
export type ConflictAutomaticResolving = {readonly isStuck: Boolean}
export type ConflictGeneration = Int
export type ConflictManualResolvingLocalView = {readonly serverView: Path}
export type ConflictManualResolvingServerView = {readonly localViews?: Array<Path> | null}
export type ConflictState = {conflictStateType: 0; automaticresolving: ConflictAutomaticResolving | null} | {conflictStateType: 1; manualresolvingserverview: ConflictManualResolvingServerView | null} | {conflictStateType: 2; manualresolvinglocalview: ConflictManualResolvingLocalView | null}
export type ConflictStateType =
  | 0 // AutomaticResolving_0
  | 1 // ManualResolvingServerView_1
  | 2 // ManualResolvingLocalView_2

export type Contact = {readonly name: String; readonly components?: Array<ContactComponent> | null}
export type ContactComponent = {readonly label: String; readonly phoneNumber?: RawPhoneNumber | null; readonly email?: EmailAddress | null}
export type CopyArgs = {readonly opID: OpID; readonly src: Path; readonly dest: Path}
export type CryptKey = {readonly KeyGeneration: Int; readonly Key: Bytes32}
export type Cryptocurrency = {readonly rowId: Int; readonly pkhash: Bytes; readonly address: String; readonly sigID: SigID; readonly type: String; readonly family: String}
export type CsrfToken = String
export type CurrentStatus = {readonly configured: Boolean; readonly registered: Boolean; readonly loggedIn: Boolean; readonly sessionIsValid: Boolean; readonly user?: User | null}
export type DbKey = {readonly dbType: DbType; readonly objType: Int; readonly key: String}
export type DbType =
  | 0 // MAIN_0
  | 1 // CHAT_1

export type DbValue = Bytes
export type DeletedTeamInfo = {readonly teamName: String; readonly deletedBy: String; readonly id: Gregor1.MsgID}
export type DesktopStatus = {readonly version: String; readonly running: Boolean; readonly log: String}
export type Device = {readonly type: String; readonly name: String; readonly deviceID: DeviceID; readonly cTime: Time; readonly mTime: Time; readonly lastUsedTime: Time; readonly encryptKey: KID; readonly verifyKey: KID; readonly status: Int}
export type DeviceDetail = {readonly device: Device; readonly eldest: Boolean; readonly provisioner?: Device | null; readonly provisionedAt?: Time | null; readonly revokedAt?: Time | null; readonly revokedBy: KID; readonly revokedByDevice?: Device | null; readonly currentDevice: Boolean}
export type DeviceEk = {readonly seed: Bytes32; readonly metadata: DeviceEkMetadata}
export type DeviceEkMetadata = {readonly kid: KID; readonly hashMeta: HashMeta; readonly generation: EkGeneration; readonly ctime: Time; readonly deviceCtime: Time}
export type DeviceEkStatement = {readonly currentDeviceEkMetadata: DeviceEkMetadata}
export type DeviceID = String
export type DeviceType =
  | 0 // DESKTOP_0
  | 1 // MOBILE_1

export type DirSizeInfo = {readonly numFiles: Int; readonly name: String; readonly humanSize: String}
export type Dirent = {readonly time: Time; readonly size: Int; readonly name: String; readonly direntType: DirentType; readonly lastWriterUnverified: User; readonly writable: Boolean; readonly prefetchStatus: PrefetchStatus; readonly prefetchProgress: PrefetchProgress}
export type DirentType =
  | 0 // FILE_0
  | 1 // DIR_1
  | 2 // SYM_2
  | 3 // EXEC_3

export type DirentWithRevision = {readonly entry: Dirent; readonly revision: KBFSRevision}
export type DismissReason = {readonly type: DismissReasonType; readonly reason: String; readonly resource: String}
export type DismissReasonType =
  | 0 // NONE_0
  | 1 // HANDLED_ELSEWHERE_1

export type DownPointer = {readonly id: TeamID; readonly nameComponent: String; readonly isDeleted: Boolean}
export type DowngradeReferenceRes = {readonly completed?: Array<BlockReferenceCount> | null; readonly failed: BlockReference}
export type DurationSec = Double
export type ED25519PublicKey = string | null
export type ED25519Signature = string | null
export type ED25519SignatureInfo = {readonly sig: ED25519Signature; readonly publicKey: ED25519PublicKey}
export type EkGeneration = Int64
export type Email = {readonly email: EmailAddress; readonly isVerified: Boolean; readonly isPrimary: Boolean; readonly visibility: IdentityVisibility}
export type EmailAddress = String
export type EmailAddressVerifiedMsg = {readonly email: EmailAddress}
export type EmailLookupResult = {readonly email: EmailAddress; readonly uid?: UID | null}
export type EncryptedBytes32 = string | null
export type EncryptedGitMetadata = {readonly v: Int; readonly e: Bytes; readonly n: BoxNonce; readonly gen: PerTeamKeyGeneration}
export type ErrorNum = Int
export type ExitCode =
  | 0 // OK_0
  | 2 // NOTOK_2
  | 4 // RESTART_4

export type ExtendedStatus = {readonly standalone: Boolean; readonly passphraseStreamCached: Boolean; readonly tsecCached: Boolean; readonly deviceSigKeyCached: Boolean; readonly deviceEncKeyCached: Boolean; readonly paperSigKeyCached: Boolean; readonly paperEncKeyCached: Boolean; readonly storedSecret: Boolean; readonly secretPromptSkip: Boolean; readonly rememberPassphrase: Boolean; readonly device?: Device | null; readonly deviceErr?: LoadDeviceErr | null; readonly logDir: String; readonly session?: SessionStatus | null; readonly defaultUsername: String; readonly provisionedUsernames?: Array<String> | null; readonly Clients?: Array<ClientStatus> | null; readonly deviceEkNames?: Array<String> | null; readonly platformInfo: PlatformInfo; readonly defaultDeviceID: DeviceID; readonly localDbStats?: Array<String> | null; readonly localChatDbStats?: Array<String> | null; readonly cacheDirSizeInfo?: Array<DirSizeInfo> | null; readonly uiRouterMapping: {[key: string]: Int}}
export type ExternalServiceConfig = {readonly schemaVersion: Int; readonly display?: ServiceDisplayConfig | null; readonly config?: ParamProofServiceConfig | null}
export type FSEditListRequest = {readonly folder: Folder; readonly requestID: Int}
export type FSErrorType =
  | 0 // ACCESS_DENIED_0
  | 1 // USER_NOT_FOUND_1
  | 2 // REVOKED_DATA_DETECTED_2
  | 3 // NOT_LOGGED_IN_3
  | 4 // TIMEOUT_4
  | 5 // REKEY_NEEDED_5
  | 6 // BAD_FOLDER_6
  | 7 // NOT_IMPLEMENTED_7
  | 8 // OLD_VERSION_8
  | 9 // OVER_QUOTA_9
  | 10 // NO_SIG_CHAIN_10
  | 11 // TOO_MANY_FOLDERS_11
  | 12 // EXDEV_NOT_SUPPORTED_12
  | 13 // DISK_LIMIT_REACHED_13
  | 14 // DISK_CACHE_ERROR_LOG_SEND_14
  | 15 // OFFLINE_ARCHIVED_15
  | 16 // OFFLINE_UNSYNCED_16

export type FSFolderEditHistory = {readonly folder: Folder; readonly serverTime: Time; readonly history?: Array<FSFolderWriterEditHistory> | null}
export type FSFolderWriterEdit = {readonly filename: String; readonly notificationType: FSNotificationType; readonly serverTime: Time}
export type FSFolderWriterEditHistory = {readonly writerName: String; readonly edits?: Array<FSFolderWriterEdit> | null; readonly deletes?: Array<FSFolderWriterEdit> | null}
export type FSNotification = {readonly filename: String; readonly status: String; readonly statusCode: FSStatusCode; readonly notificationType: FSNotificationType; readonly errorType: FSErrorType; readonly params: {[key: string]: String}; readonly writerUid: UID; readonly localTime: Time; readonly folderType: FolderType}
export type FSNotificationType =
  | 0 // ENCRYPTING_0
  | 1 // DECRYPTING_1
  | 2 // SIGNING_2
  | 3 // VERIFYING_3
  | 4 // REKEYING_4
  | 5 // CONNECTION_5
  | 6 // MD_READ_SUCCESS_6
  | 7 // FILE_CREATED_7
  | 8 // FILE_MODIFIED_8
  | 9 // FILE_DELETED_9
  | 10 // FILE_RENAMED_10
  | 11 // INITIALIZED_11
  | 12 // SYNC_CONFIG_CHANGED_12

export type FSPathSyncStatus = {readonly folderType: FolderType; readonly path: String; readonly syncingBytes: Int64; readonly syncingOps: Int64; readonly syncedBytes: Int64}
export type FSSettings = {readonly spaceAvailableNotificationThreshold: Int64}
export type FSStatusCode =
  | 0 // START_0
  | 1 // FINISH_1
  | 2 // ERROR_2

export type FSSyncStatus = {readonly totalSyncingBytes: Int64; readonly syncingPaths?: Array<String> | null; readonly endEstimate?: Time | null}
export type FSSyncStatusRequest = {readonly requestID: Int}
export type FastTeamData = {readonly frozen: Boolean; readonly tombstoned: Boolean; readonly name: TeamName; readonly chain: FastTeamSigChainState; readonly perTeamKeySeeds: /* perTeamKeySeedsUnverified */ {[key: string]: PerTeamKeySeed}; readonly latestKeyGeneration: PerTeamKeyGeneration; readonly readerKeyMasks: {[key: string]: {[key: string]: MaskB64}}; readonly latestSeqnoHint: Seqno; readonly cachedAt: Time; readonly loadedLatest: Boolean}
export type FastTeamLoadArg = {readonly ID: TeamID; readonly public: Boolean; readonly assertTeamName?: TeamName | null; readonly applications?: Array<TeamApplication> | null; readonly keyGenerationsNeeded?: Array<PerTeamKeyGeneration> | null; readonly needLatestKey: Boolean; readonly forceRefresh: Boolean}
export type FastTeamLoadRes = {readonly name: TeamName; readonly applicationKeys?: Array<TeamApplicationKey> | null}
export type FastTeamSigChainState = {readonly ID: TeamID; readonly public: Boolean; readonly rootAncestor: TeamName; readonly nameDepth: Int; readonly last?: LinkTriple | null; readonly perTeamKeys: {[key: string]: PerTeamKey}; readonly perTeamKeySeedsVerified: {[key: string]: PerTeamKeySeed}; readonly downPointers: {[key: string]: DownPointer}; readonly lastUpPointer?: UpPointer | null; readonly perTeamKeyCTime: UnixTime; readonly linkIDs: {[key: string]: LinkID}; readonly merkleInfo: {[key: string]: MerkleRootV2}}
export type FavoritesResult = {readonly favoriteFolders?: Array<Folder> | null; readonly ignoredFolders?: Array<Folder> | null; readonly newFolders?: Array<Folder> | null}
export type Feature = {readonly allow: Boolean; readonly defaultValue: Boolean; readonly readonly: Boolean; readonly label: String}
export type File = {readonly path: String}
export type FileContent = {readonly data: Bytes; readonly progress: Progress}
export type FileDescriptor = {readonly name: String; readonly type: FileType}
export type FileType =
  | 0 // UNKNOWN_0
  | 1 // DIRECTORY_1
  | 2 // FILE_2

export type FindNextMDResponse = {readonly kbfsRoot: MerkleRoot; readonly merkleNodes?: Array<Bytes> | null; readonly rootSeqno: Seqno; readonly rootHash: HashMeta}
export type FirstStepResult = {readonly valPlusTwo: Int}
export type Folder = {readonly name: String; readonly private: Boolean; readonly created: Boolean; readonly folderType: FolderType; readonly team_id /* teamID */?: TeamID | null; readonly reset_members /* resetMembers */?: Array<User> | null; readonly mtime?: Time | null; readonly conflictState?: ConflictState | null}
export type FolderConflictType =
  | 0 // NONE_0
  | 1 // IN_CONFLICT_1
  | 2 // IN_CONFLICT_AND_STUCK_2

export type FolderSyncConfig = {readonly mode: FolderSyncMode; readonly paths?: Array<String> | null}
export type FolderSyncConfigAndStatus = {readonly config: FolderSyncConfig; readonly status: FolderSyncStatus}
export type FolderSyncConfigAndStatusWithFolder = {readonly folder: Folder; readonly config: FolderSyncConfig; readonly status: FolderSyncStatus}
export type FolderSyncMode =
  | 0 // DISABLED_0
  | 1 // ENABLED_1
  | 2 // PARTIAL_2

export type FolderSyncStatus = {readonly localDiskBytesAvailable: Int64; readonly localDiskBytesTotal: Int64; readonly prefetchStatus: PrefetchStatus; readonly prefetchProgress: PrefetchProgress; readonly storedBytesTotal: Int64; readonly outOfSyncSpace: Boolean}
export type FolderType =
  | 0 // UNKNOWN_0
  | 1 // PRIVATE_1
  | 2 // PUBLIC_2
  | 3 // TEAM_3

export type ForkType =
  | 0 // NONE_0
  | 1 // AUTO_1
  | 2 // WATCHDOG_2
  | 3 // LAUNCHD_3
  | 4 // SYSTEMD_4

export type FullName = String
export type FullNamePackage = {readonly version: FullNamePackageVersion; readonly fullName: FullName; readonly eldestSeqno: Seqno; readonly status: StatusCode; readonly cachedAt: Time}
export type FullNamePackageVersion =
  | 0 // V0_0
  | 1 // V1_1
  | 2 // V2_2

export type FullStatus = {readonly username: String; readonly configPath: String; readonly curStatus: CurrentStatus; readonly extStatus: ExtendedStatus; readonly client: KbClientStatus; readonly service: KbServiceStatus; readonly kbfs: KBFSStatus; readonly desktop: DesktopStatus; readonly updater: UpdaterStatus; readonly start: StartStatus; readonly git: GitStatus}
export type FuseMountInfo = {readonly path: String; readonly fstype: String; readonly output: String}
export type FuseStatus = {readonly version: String; readonly bundleVersion: String; readonly kextID: String; readonly path: String; readonly kextStarted: Boolean; readonly installStatus: InstallStatus; readonly installAction: InstallAction; readonly mountInfos?: Array<FuseMountInfo> | null; readonly status: Status}
export type GPGKey = {readonly algorithm: String; readonly keyID: String; readonly creation: String; readonly expiration: String; readonly identities?: Array<PGPIdentity> | null}
export type GPGMethod =
  | 0 // GPG_NONE_0
  | 1 // GPG_IMPORT_1
  | 2 // GPG_SIGN_2

export type GUIEntryArg = {readonly windowTitle: String; readonly prompt: String; readonly username: String; readonly submitLabel: String; readonly cancelLabel: String; readonly retryLabel: String; readonly type: PassphraseType; readonly features: GUIEntryFeatures}
export type GUIEntryFeatures = {readonly showTyping: Feature}
export type GcOptions = {readonly maxLooseRefs: Int; readonly pruneMinLooseObjects: Int; readonly pruneExpireTime: Time; readonly maxObjectPacks: Int}
export type GetBlockRes = {readonly blockKey: String; readonly buf: Bytes; readonly size: Int; readonly status: BlockStatus}
export type GetLockdownResponse = {readonly history?: Array<LockdownHistory> | null; readonly status: Boolean}
export type GetPassphraseRes = {readonly passphrase: String; readonly storeSecret: Boolean}
export type GetRevisionsArgs = {readonly opID: OpID; readonly path: Path; readonly spanType: RevisionSpanType}
export type GetRevisionsResult = {readonly revisions?: Array<DirentWithRevision> | null; readonly progress: Progress}
export type GetTLFCryptKeysRes = {readonly nameIDBreaks: CanonicalTLFNameAndIDWithBreaks; readonly CryptKeys?: Array<CryptKey> | null}
export type GitCommit = {readonly commitHash: String; readonly message: String; readonly authorName: String; readonly authorEmail: String; readonly ctime: Time}
export type GitLocalMetadata = {readonly repoName: GitRepoName; readonly refs?: Array<GitRefMetadata> | null; readonly pushType: GitPushType; readonly previousRepoName: GitRepoName}
export type GitLocalMetadataV1 = {readonly repoName: GitRepoName}
export type GitLocalMetadataVersion = 1 // V1_1

export type GitLocalMetadataVersioned = {version: 1; v1: GitLocalMetadataV1 | null}
export type GitPushType =
  | 0 // DEFAULT_0
  | 1 // CREATEREPO_1
  | 3 // RENAMEREPO_3

export type GitRefMetadata = {readonly refName: String; readonly commits?: Array<GitCommit> | null; readonly moreCommitsAvailable: Boolean; readonly isDelete: Boolean}
export type GitRepoInfo = {readonly folder: Folder; readonly repoID: RepoID; readonly localMetadata: GitLocalMetadata; readonly serverMetadata: GitServerMetadata; readonly repoUrl: String; readonly globalUniqueID: String; readonly canDelete: Boolean; readonly teamRepoSettings?: GitTeamRepoSettings | null}
export type GitRepoName = String
export type GitRepoResult = {state: 0; err: String | null} | {state: 1; ok: GitRepoInfo | null}
export type GitRepoResultState =
  | 0 // ERR_0
  | 1 // OK_1

export type GitServerMetadata = {readonly ctime: Time; readonly mtime: Time; readonly lastModifyingUsername: String; readonly lastModifyingDeviceID: DeviceID; readonly lastModifyingDeviceName: String}
export type GitStatus = {readonly log: String}
export type GitTeamRepoSettings = {readonly channelName?: String | null; readonly chatDisabled: Boolean}
export type HasServerKeysRes = {readonly hasServerKeys: Boolean}
export type HashMeta = Bytes
export type Hello2Res = {readonly encryptionKey: KID; readonly sigPayload: HelloRes; readonly deviceEkKID: KID}
export type HelloRes = String
export type HomeScreen = {readonly lastViewed: Time; readonly version: Int; readonly visits: Int; readonly items?: Array<HomeScreenItem> | null; readonly followSuggestions?: Array<HomeUserSummary> | null; readonly announcementsVersion: Int}
export type HomeScreenAnnouncement = {readonly id: HomeScreenAnnouncementID; readonly version: HomeScreenAnnouncementVersion; readonly appLink: AppLinkType; readonly confirmLabel: String; readonly dismissable: Boolean; readonly iconUrl: String; readonly text: String; readonly url: String}
export type HomeScreenAnnouncementID = Int
export type HomeScreenAnnouncementVersion = Int
export type HomeScreenItem = {readonly badged: Boolean; readonly data: HomeScreenItemData}
export type HomeScreenItemData = {t: 1; todo: HomeScreenTodo | null} | {t: 2; people: HomeScreenPeopleNotification | null} | {t: 3; announcement: HomeScreenAnnouncement | null}
export type HomeScreenItemID = String
export type HomeScreenItemType =
  | 1 // TODO_1
  | 2 // PEOPLE_2
  | 3 // ANNOUNCEMENT_3

export type HomeScreenPeopleNotification = {t: 1; followed: HomeScreenPeopleNotificationFollowed | null} | {t: 2; followedMulti: HomeScreenPeopleNotificationFollowedMulti | null}
export type HomeScreenPeopleNotificationFollowed = {readonly followTime: Time; readonly followedBack: Boolean; readonly user: UserSummary}
export type HomeScreenPeopleNotificationFollowedMulti = {readonly followers?: Array<HomeScreenPeopleNotificationFollowed> | null; readonly numOthers: Int}
export type HomeScreenPeopleNotificationType =
  | 1 // FOLLOWED_1
  | 2 // FOLLOWED_MULTI_2

export type HomeScreenTodo = void
export type HomeScreenTodoType =
  | 0 // NONE_0
  | 1 // BIO_1
  | 2 // PROOF_2
  | 3 // DEVICE_3
  | 4 // FOLLOW_4
  | 5 // CHAT_5
  | 6 // PAPERKEY_6
  | 7 // TEAM_7
  | 8 // FOLDER_8
  | 9 // GIT_REPO_9
  | 10 // TEAM_SHOWCASE_10
  | 11 // AVATAR_USER_11
  | 12 // AVATAR_TEAM_12
  | 10000 // ANNONCEMENT_PLACEHOLDER_10000

export type HomeUserSummary = {readonly uid: UID; readonly username: String; readonly bio: String; readonly fullName: String; readonly pics?: Pics | null}
export type Identify2Res = {readonly upk: UserPlusKeys; readonly identifiedAt: Time; readonly trackBreaks?: IdentifyTrackBreaks | null}
export type Identify2ResUPK2 = {readonly upk: UserPlusKeysV2AllIncarnations; readonly identifiedAt: Time; readonly trackBreaks?: IdentifyTrackBreaks | null}
export type Identify3Assertion = String
export type Identify3GUIID = String
export type Identify3ResultType =
  | 0 // OK_0
  | 1 // BROKEN_1
  | 2 // NEEDS_UPGRADE_2
  | 3 // CANCELED_3

export type Identify3Row = {readonly guiID: Identify3GUIID; readonly key: String; readonly value: String; readonly priority: Int; readonly siteURL: String; readonly siteIcon?: Array<SizedImage> | null; readonly siteIconFull?: Array<SizedImage> | null; readonly proofURL: String; readonly sigID: SigID; readonly ctime: Time; readonly state: Identify3RowState; readonly metas?: Array<Identify3RowMeta> | null; readonly color: Identify3RowColor; readonly kid?: KID | null}
export type Identify3RowColor =
  | 1 // BLUE_1
  | 2 // RED_2
  | 3 // BLACK_3
  | 4 // GREEN_4
  | 5 // GRAY_5
  | 6 // YELLOW_6
  | 7 // ORANGE_7

export type Identify3RowMeta = {readonly color: Identify3RowColor; readonly label: String}
export type Identify3RowState =
  | 1 // CHECKING_1
  | 2 // VALID_2
  | 3 // ERROR_3
  | 4 // WARNING_4
  | 5 // REVOKED_5

export type IdentifyKey = {readonly pgpFingerprint: Bytes; readonly KID: KID; readonly trackDiff?: TrackDiff | null; readonly breaksTracking: Boolean; readonly sigID: SigID}
export type IdentifyLiteRes = {readonly ul: UserOrTeamLite; readonly trackBreaks?: IdentifyTrackBreaks | null}
export type IdentifyOutcome = {readonly username: String; readonly status?: Status | null; readonly warnings?: Array<String> | null; readonly trackUsed?: TrackSummary | null; readonly trackStatus: TrackStatus; readonly numTrackFailures: Int; readonly numTrackChanges: Int; readonly numProofFailures: Int; readonly numRevoked: Int; readonly numProofSuccesses: Int; readonly revoked?: Array<TrackDiff> | null; readonly trackOptions: TrackOptions; readonly forPGPPull: Boolean; readonly reason: IdentifyReason}
export type IdentifyProofBreak = {readonly remoteProof: RemoteProof; readonly lcr: LinkCheckResult}
export type IdentifyReason = {readonly type: IdentifyReasonType; readonly reason: String; readonly resource: String}
export type IdentifyReasonType =
  | 0 // NONE_0
  | 1 // ID_1
  | 2 // TRACK_2
  | 3 // ENCRYPT_3
  | 4 // DECRYPT_4
  | 5 // VERIFY_5
  | 6 // RESOURCE_6
  | 7 // BACKGROUND_7

export type IdentifyRow = {readonly rowId: Int; readonly proof: RemoteProof; readonly trackDiff?: TrackDiff | null}
export type IdentifyTrackBreaks = {readonly keys?: Array<IdentifyKey> | null; readonly proofs?: Array<IdentifyProofBreak> | null}
export type Identity = {readonly status?: Status | null; readonly whenLastTracked: Time; readonly proofs?: Array<IdentifyRow> | null; readonly cryptocurrency?: Array<Cryptocurrency> | null; readonly revoked?: Array<TrackDiff> | null; readonly revokedDetails?: Array<RevokedProof> | null; readonly breaksTracking: Boolean}
export type IdentityVisibility =
  | 0 // PRIVATE_0
  | 1 // PUBLIC_1

export type ImageCropRect = {readonly x0: Int; readonly y0: Int; readonly x1: Int; readonly y1: Int}
export type ImplicitRole = {readonly role: TeamRole; readonly ancestor: TeamID}
export type ImplicitTeamConflictInfo = {readonly generation: ConflictGeneration; readonly time: Time}
export type ImplicitTeamDisplayName = {readonly isPublic: Boolean; readonly writers: ImplicitTeamUserSet; readonly readers: ImplicitTeamUserSet; readonly conflictInfo?: ImplicitTeamConflictInfo | null}
export type ImplicitTeamUserSet = {readonly keybaseUsers?: Array<String> | null; readonly unresolvedUsers?: Array<SocialAssertion> | null}
export type InstallAction =
  | 0 // UNKNOWN_0
  | 1 // NONE_1
  | 2 // UPGRADE_2
  | 3 // REINSTALL_3
  | 4 // INSTALL_4

export type InstallResult = {readonly componentResults?: Array<ComponentResult> | null; readonly status: Status; readonly fatal: Boolean}
export type InstallStatus =
  | 0 // UNKNOWN_0
  | 1 // ERROR_1
  | 2 // NOT_INSTALLED_2
  | 4 // INSTALLED_4

export type InterestingPerson = {readonly uid: UID; readonly username: String; readonly fullname: String}
export type KBFSArchivedParam = {KBFSArchivedType: 0; revision: KBFSRevision | null} | {KBFSArchivedType: 1; time: Time | null} | {KBFSArchivedType: 2; timeString: String | null} | {KBFSArchivedType: 3; relTimeString: String | null}
export type KBFSArchivedPath = {readonly path: String; readonly archivedParam: KBFSArchivedParam}
export type KBFSArchivedType =
  | 0 // REVISION_0
  | 1 // TIME_1
  | 2 // TIME_STRING_2
  | 3 // REL_TIME_STRING_3

export type KBFSRevision = Int64
export type KBFSRoot = {readonly treeID: MerkleTreeID; readonly root: KBFSRootHash}
export type KBFSRootHash = Bytes
export type KBFSStatus = {readonly version: String; readonly installedVersion: String; readonly running: Boolean; readonly pid: String; readonly log: String; readonly mount: String}
export type KBFSTeamSettings = {readonly tlfID: TLFID}
export type KID = String
export type KbClientStatus = {readonly version: String}
export type KbServiceStatus = {readonly version: String; readonly running: Boolean; readonly pid: String; readonly log: String; readonly ekLog: String}
export type KeyBundle = {readonly version: Int; readonly bundle: Bytes}
export type KeyBundleResponse = {readonly WriterBundle: KeyBundle; readonly ReaderBundle: KeyBundle}
export type KeyHalf = {readonly user: UID; readonly deviceKID: KID; readonly key: Bytes}
export type KeyInfo = {readonly fingerprint: String; readonly key: String; readonly desc: String}
export type KeyType =
  | 0 // NONE_0
  | 1 // NACL_1
  | 2 // PGP_2

export type KeybaseTime = {readonly unix: Time; readonly chain: Seqno}
export type LeaseID = String
export type LinkCheckResult = {readonly proofId: Int; readonly proofResult: ProofResult; readonly snoozedResult: ProofResult; readonly torWarning: Boolean; readonly tmpTrackExpireTime: Time; readonly cached?: CheckResult | null; readonly diff?: TrackDiff | null; readonly remoteDiff?: TrackDiff | null; readonly hint?: SigHint | null; readonly breaksTracking: Boolean}
export type LinkID = String
export type LinkTriple = {readonly seqno: Seqno; readonly seqType: SeqType; readonly linkID: LinkID}
export type ListArgs = {readonly opID: OpID; readonly path: Path; readonly filter: ListFilter}
export type ListFilter =
  | 0 // NO_FILTER_0
  | 1 // FILTER_ALL_HIDDEN_1
  | 2 // FILTER_SYSTEM_HIDDEN_2

export type ListResult = {readonly files?: Array<File> | null}
export type ListToDepthArgs = {readonly opID: OpID; readonly path: Path; readonly filter: ListFilter; readonly depth: Int}
export type LoadAvatarsRes = {readonly picmap: {[key: string]: {[key: string]: AvatarUrl}}}
export type LoadDeviceErr = {readonly where: String; readonly desc: String}
export type LoadTeamArg = {readonly ID: TeamID; readonly name: String; readonly public: Boolean; readonly needAdmin: Boolean; readonly refreshUIDMapper: Boolean; readonly refreshers: TeamRefreshers; readonly forceFullReload: Boolean; readonly forceRepoll: Boolean; readonly staleOK: Boolean; readonly allowNameLookupBurstCache: Boolean}
export type LockContext = {readonly requireLockID: LockID; readonly releaseAfterSuccess: Boolean}
export type LockID = Long
export type LockdownHistory = {readonly status: Boolean; readonly creationTime: Time; readonly deviceID: DeviceID; readonly deviceName: String}
export type LogLevel =
  | 0 // NONE_0
  | 1 // DEBUG_1
  | 2 // INFO_2
  | 3 // NOTICE_3
  | 4 // WARN_4
  | 5 // ERROR_5
  | 6 // CRITICAL_6
  | 7 // FATAL_7

export type LogSendID = String
export type LookupImplicitTeamRes = {readonly teamID: TeamID; readonly name: TeamName; readonly displayName: ImplicitTeamDisplayName; readonly tlfID: TLFID}
export type MDBlock = {readonly version: Int; readonly timestamp: Time; readonly block: Bytes}
export type MDPriority = Int
export type MaskB64 = Bytes
export type MemberInfo = {readonly userID: UID; readonly teamID: TeamID; readonly fqName: String; readonly isImplicitTeam: Boolean; readonly isOpenTeam: Boolean; readonly role: TeamRole; readonly implicit?: ImplicitRole | null; readonly memberCount: Int; readonly allowProfilePromote: Boolean; readonly isMemberShowcased: Boolean}
export type MerkleRoot = {readonly version: Int; readonly root: Bytes}
export type MerkleRootAndTime = {readonly root: MerkleRootV2; readonly updateTime: Time; readonly fetchTime: Time}
export type MerkleRootV2 = {readonly seqno: Seqno; readonly hashMeta: HashMeta}
export type MerkleStoreEntry = {readonly hash: MerkleStoreKitHash; readonly entry: MerkleStoreEntryString}
export type MerkleStoreEntryString = String
export type MerkleStoreKit = String
export type MerkleStoreKitHash = String
export type MerkleStoreSupportedVersion = Int
export type MerkleTreeID =
  | 0 // MASTER_0
  | 1 // KBFS_PUBLIC_1
  | 2 // KBFS_PRIVATE_2
  | 3 // KBFS_PRIVATETEAM_3

export type MerkleTreeLocation = {readonly leaf: UserOrTeamID; readonly loc: SigChainLocation}
export type MetadataResponse = {readonly folderID: String; readonly mdBlocks?: Array<MDBlock> | null}
export type MobileAppState =
  | 0 // FOREGROUND_0
  | 1 // BACKGROUND_1
  | 2 // INACTIVE_2
  | 3 // BACKGROUNDACTIVE_3

export type MoveArgs = {readonly opID: OpID; readonly src: Path; readonly dest: Path}
export type NaclDHKeyPrivate = string | null
export type NaclDHKeyPublic = string | null
export type NaclSigningKeyPrivate = string | null
export type NaclSigningKeyPublic = string | null
export type NextMerkleRootRes = {readonly res?: MerkleRootV2 | null}
export type NotificationChannels = {readonly session: Boolean; readonly users: Boolean; readonly kbfs: Boolean; readonly kbfsdesktop: Boolean; readonly kbfslegacy: Boolean; readonly tracking: Boolean; readonly favorites: Boolean; readonly paperkeys: Boolean; readonly keyfamily: Boolean; readonly service: Boolean; readonly app: Boolean; readonly chat: Boolean; readonly pgp: Boolean; readonly kbfsrequest: Boolean; readonly badges: Boolean; readonly reachability: Boolean; readonly team: Boolean; readonly ephemeral: Boolean; readonly chatkbfsedits: Boolean; readonly chatdev: Boolean; readonly deviceclone: Boolean; readonly chatattachments: Boolean; readonly wallet: Boolean; readonly audit: Boolean}
export type OfflineAvailability =
  | 0 // NONE_0
  | 1 // BEST_EFFORT_1

export type OpDescription = {asyncOp: 0; list: ListArgs | null} | {asyncOp: 1; listRecursive: ListArgs | null} | {asyncOp: 7; listRecursiveToDepth: ListToDepthArgs | null} | {asyncOp: 2; read: ReadArgs | null} | {asyncOp: 3; write: WriteArgs | null} | {asyncOp: 4; copy: CopyArgs | null} | {asyncOp: 5; move: MoveArgs | null} | {asyncOp: 6; remove: RemoveArgs | null} | {asyncOp: 8; getRevisions: GetRevisionsArgs | null}
export type OpID = string | null
export type OpProgress = {readonly start: Time; readonly endEstimate: Time; readonly opType: AsyncOps; readonly bytesTotal: Int64; readonly bytesRead: Int64; readonly bytesWritten: Int64; readonly filesTotal: Int64; readonly filesRead: Int64; readonly filesWritten: Int64}
export type OpenFlags =
  | 0 // READ_0
  | 1 // REPLACE_1
  | 2 // EXISTING_2
  | 4 // WRITE_4
  | 8 // APPEND_8
  | 16 // DIRECTORY_16

export type OutOfDateInfo = {readonly upgradeTo: String; readonly upgradeURI: String; readonly customMessage: String; readonly criticalClockSkew: Long}
export type Outcome =
  | 0 // NONE_0
  | 1 // FIXED_1
  | 2 // IGNORED_2

export type PGPCreateUids = {readonly useDefault: Boolean; readonly ids?: Array<PGPIdentity> | null}
export type PGPDecryptOptions = {readonly assertSigned: Boolean; readonly signedBy: String}
export type PGPEncryptOptions = {readonly recipients?: Array<String> | null; readonly noSign: Boolean; readonly noSelf: Boolean; readonly binaryOut: Boolean; readonly keyQuery: String}
export type PGPFingerprint = string | null
export type PGPIdentity = {readonly username: String; readonly comment: String; readonly email: String}
export type PGPPurgeRes = {readonly filenames?: Array<String> | null}
export type PGPQuery = {readonly secret: Boolean; readonly query: String; readonly exactMatch: Boolean}
export type PGPSigVerification = {readonly isSigned: Boolean; readonly verified: Boolean; readonly signer: User; readonly signKey: PublicKey}
export type PGPSignOptions = {readonly keyQuery: String; readonly mode: SignMode; readonly binaryIn: Boolean; readonly binaryOut: Boolean}
export type PGPVerifyOptions = {readonly signedBy: String; readonly signature: Bytes}
export type ParamProofJSON = {readonly sigHash: SigID; readonly kbUsername: String}
export type ParamProofLogoConfig = {readonly svgBlack: String; readonly svgFull: String}
export type ParamProofServiceConfig = {readonly version: Int; readonly domain: String; readonly displayName: String; readonly logo?: ParamProofLogoConfig | null; readonly description: String; readonly usernameConfig: ParamProofUsernameConfig; readonly brandColor: String; readonly prefillUrl: String; readonly profileUrl: String; readonly checkUrl: String; readonly checkPath?: Array<SelectorEntry> | null; readonly avatarPath?: Array<SelectorEntry> | null}
export type ParamProofUsernameConfig = {readonly re: String; readonly min: Int; readonly max: Int}
export type PassphraseRecoveryPromptType = 0 // ENCRYPTED_PGP_KEYS_0

export type PassphraseStream = {readonly passphraseStream: Bytes; readonly generation: Int}
export type PassphraseType =
  | 0 // NONE_0
  | 1 // PAPER_KEY_1
  | 2 // PASS_PHRASE_2
  | 3 // VERIFY_PASS_PHRASE_3

export type Path = {PathType: 0; local: String | null} | {PathType: 1; kbfs: String | null} | {PathType: 2; kbfsArchived: KBFSArchivedPath | null}
export type PathType =
  | 0 // LOCAL_0
  | 1 // KBFS_1
  | 2 // KBFS_ARCHIVED_2

export type PerTeamKey = {readonly gen: PerTeamKeyGeneration; readonly seqno: Seqno; readonly sigKID: KID; readonly encKID: KID}
export type PerTeamKeyGeneration = Int
export type PerTeamKeySeed = string | null
export type PerTeamKeySeedItem = {readonly seed: PerTeamKeySeed; readonly generation: PerTeamKeyGeneration; readonly seqno: Seqno}
export type PerUserKey = {readonly gen: Int; readonly seqno: Seqno; readonly sigKID: KID; readonly encKID: KID; readonly signedByKID: KID}
export type PerUserKeyBox = {readonly generation: PerUserKeyGeneration; readonly box: String; readonly receiverKID: KID}
export type PerUserKeyGeneration = Int
export type PhoneLookupResult = {readonly uid: UID; readonly username: String; readonly ctime: UnixTime}
export type PhoneNumber = String
export type PhoneNumberAddedMsg = {readonly phoneNumber: PhoneNumber}
export type PhoneNumberLookupResult = {readonly phoneNumber: RawPhoneNumber; readonly coercedPhoneNumber: PhoneNumber; readonly err?: String | null; readonly uid?: UID | null}
export type PhoneNumberSupersededMsg = {readonly phoneNumber: PhoneNumber}
export type PhoneNumberVerifiedMsg = {readonly phoneNumber: PhoneNumber}
export type Pics = {readonly square40: String; readonly square200: String; readonly square360: String}
export type PingResponse = {readonly timestamp: Time}
export type PlatformInfo = {readonly os: String; readonly osVersion: String; readonly arch: String; readonly goVersion: String}
export type PrefetchProgress = {readonly start: Time; readonly endEstimate: Time; readonly bytesTotal: Int64; readonly bytesFetched: Int64}
export type PrefetchStatus =
  | 0 // NOT_STARTED_0
  | 1 // IN_PROGRESS_1
  | 2 // COMPLETE_2

export type Probe = {readonly i: /* index */ Int; readonly s: /* teamSeqno */ Seqno}
export type ProblemSet = {readonly user: User; readonly kid: KID; readonly tlfs?: Array<ProblemTLF> | null}
export type ProblemSetDevices = {readonly problemSet: ProblemSet; readonly devices?: Array<Device> | null}
export type ProblemTLF = {readonly tlf: TLF; readonly score: Int; readonly solution_kids?: Array<KID> | null}
export type Process = {readonly pid: String; readonly command: String; readonly fileDescriptors?: Array<FileDescriptor> | null}
export type ProcessedContact = {readonly contactIndex: Int; readonly contactName: String; readonly component: ContactComponent; readonly resolved: Boolean; readonly uid: UID; readonly username: String; readonly fullName: String; readonly following: Boolean; readonly displayName: String; readonly displayLabel: String}
export type ProfileTeamLoadRes = {readonly loadTimeNsec: Long}
export type Progress = Int
export type PromptDefault =
  | 0 // NONE_0
  | 1 // YES_1
  | 2 // NO_2

export type PromptOverwriteType =
  | 0 // SOCIAL_0
  | 1 // SITE_1

export type ProofResult = {readonly state: ProofState; readonly status: ProofStatus; readonly desc: String}
export type ProofState =
  | 0 // NONE_0
  | 1 // OK_1
  | 2 // TEMP_FAILURE_2
  | 3 // PERM_FAILURE_3
  | 4 // LOOKING_4
  | 5 // SUPERSEDED_5
  | 6 // POSTED_6
  | 7 // REVOKED_7
  | 8 // DELETED_8
  | 9 // UNKNOWN_TYPE_9
  | 10 // SIG_HINT_MISSING_10
  | 11 // UNCHECKED_11

export type ProofStatus =
  | 0 // NONE_0
  | 1 // OK_1
  | 2 // LOCAL_2
  | 3 // FOUND_3
  | 100 // BASE_ERROR_100
  | 101 // HOST_UNREACHABLE_101
  | 103 // PERMISSION_DENIED_103
  | 106 // FAILED_PARSE_106
  | 107 // DNS_ERROR_107
  | 108 // AUTH_FAILED_108
  | 129 // HTTP_429_129
  | 150 // HTTP_500_150
  | 160 // TIMEOUT_160
  | 170 // INTERNAL_ERROR_170
  | 171 // UNCHECKED_171
  | 172 // MISSING_PVL_172
  | 200 // BASE_HARD_ERROR_200
  | 201 // NOT_FOUND_201
  | 202 // CONTENT_FAILURE_202
  | 203 // BAD_USERNAME_203
  | 204 // BAD_REMOTE_ID_204
  | 205 // TEXT_NOT_FOUND_205
  | 206 // BAD_ARGS_206
  | 207 // CONTENT_MISSING_207
  | 208 // TITLE_NOT_FOUND_208
  | 209 // SERVICE_ERROR_209
  | 210 // TOR_SKIPPED_210
  | 211 // TOR_INCOMPATIBLE_211
  | 230 // HTTP_300_230
  | 240 // HTTP_400_240
  | 260 // HTTP_OTHER_260
  | 270 // EMPTY_JSON_270
  | 301 // DELETED_301
  | 302 // SERVICE_DEAD_302
  | 303 // BAD_SIGNATURE_303
  | 304 // BAD_API_URL_304
  | 305 // UNKNOWN_TYPE_305
  | 306 // NO_HINT_306
  | 307 // BAD_HINT_TEXT_307
  | 308 // INVALID_PVL_308

export type ProofSuggestion = {readonly key: String; readonly belowFold: Boolean; readonly profileText: String; readonly profileIcon?: Array<SizedImage> | null; readonly pickerText: String; readonly pickerSubtext: String; readonly pickerIcon?: Array<SizedImage> | null; readonly metas?: Array<Identify3RowMeta> | null}
export type ProofSuggestionsRes = {readonly suggestions?: Array<ProofSuggestion> | null; readonly showMore: Boolean}
export type ProofType =
  | 0 // NONE_0
  | 1 // KEYBASE_1
  | 2 // TWITTER_2
  | 3 // GITHUB_3
  | 4 // REDDIT_4
  | 5 // COINBASE_5
  | 6 // HACKERNEWS_6
  | 8 // FACEBOOK_8
  | 9 // GENERIC_SOCIAL_9
  | 1000 // GENERIC_WEB_SITE_1000
  | 1001 // DNS_1001
  | 1002 // PGP_1002
  | 100001 // ROOTER_100001

export type Proofs = {readonly social?: Array<TrackProof> | null; readonly web?: Array<WebProof> | null; readonly publicKeys?: Array<PublicKey> | null}
export type ProveParameters = {readonly logoFull?: Array<SizedImage> | null; readonly logoBlack?: Array<SizedImage> | null; readonly title: String; readonly subtext: String; readonly suffix: String; readonly buttonLabel: String}
export type ProvisionMethod =
  | 0 // DEVICE_0
  | 1 // PAPER_KEY_1
  | 2 // PASSPHRASE_2
  | 3 // GPG_IMPORT_3
  | 4 // GPG_SIGN_4

export type PublicKey = {readonly KID: KID; readonly PGPFingerprint: String; readonly PGPIdentities?: Array<PGPIdentity> | null; readonly isSibkey: Boolean; readonly isEldest: Boolean; readonly parentID: String; readonly deviceID: DeviceID; readonly deviceDescription: String; readonly deviceType: String; readonly cTime: Time; readonly eTime: Time; readonly isRevoked: Boolean}
export type PublicKeyV2 = {keyType: 1; nacl: PublicKeyV2NaCl | null} | {keyType: 2; pgp: PublicKeyV2PGPSummary | null}
export type PublicKeyV2Base = {readonly kid: KID; readonly isSibkey: Boolean; readonly isEldest: Boolean; readonly cTime: Time; readonly eTime: Time; readonly provisioning: SignatureMetadata; readonly revocation?: SignatureMetadata | null}
export type PublicKeyV2NaCl = {readonly base: PublicKeyV2Base; readonly parent?: KID | null; readonly deviceID: DeviceID; readonly deviceDescription: String; readonly deviceType: String}
export type PublicKeyV2PGPSummary = {readonly base: PublicKeyV2Base; readonly fingerprint: PGPFingerprint; readonly identities?: Array<PGPIdentity> | null}
export type PushReason =
  | 0 // NONE_0
  | 1 // RECONNECTED_1
  | 2 // NEW_DATA_2

export type RawPhoneNumber = String
export type Reachability = {readonly reachable: Reachable}
export type Reachable =
  | 0 // UNKNOWN_0
  | 1 // YES_1
  | 2 // NO_2

export type ReacjiSkinTone = Int
export type ReadArgs = {readonly opID: OpID; readonly path: Path; readonly offset: Long; readonly size: Int}
export type ReaderKeyMask = {readonly application: TeamApplication; readonly generation: PerTeamKeyGeneration; readonly mask: MaskB64}
export type ReferenceCountRes = {readonly counts?: Array<BlockIdCount> | null}
export type RegionCode = String
export type RegisterAddressRes = {readonly type: String; readonly family: String}
export type RekeyEvent = {readonly eventType: RekeyEventType; readonly interruptType: Int}
export type RekeyEventType =
  | 0 // NONE_0
  | 1 // NOT_LOGGED_IN_1
  | 2 // API_ERROR_2
  | 3 // NO_PROBLEMS_3
  | 4 // LOAD_ME_ERROR_4
  | 5 // CURRENT_DEVICE_CAN_REKEY_5
  | 6 // DEVICE_LOAD_ERROR_6
  | 7 // HARASS_7
  | 8 // NO_GREGOR_MESSAGES_8

export type RekeyRequest = {readonly folderID: String; readonly revision: Long}
export type RemoteProof = {readonly proofType: ProofType; readonly key: String; readonly value: String; readonly displayMarkup: String; readonly sigID: SigID; readonly mTime: Time}
export type RemoteTrack = {readonly username: String; readonly uid: UID; readonly linkID: LinkID}
export type RemoveArgs = {readonly opID: OpID; readonly path: Path; readonly recursive: Boolean}
export type RepoID = String
export type ResetLink = {readonly ctime: UnixTime; readonly merkleRoot: ResetMerkleRoot; readonly prev: ResetPrev; readonly resetSeqno: Seqno; readonly type: ResetType; readonly uid: UID}
export type ResetMerkleRoot = {readonly hashMeta: HashMeta; readonly seqno: Seqno}
export type ResetPrev = {readonly eldestKID?: KID | null; readonly lastSeqno: Seqno; readonly reset: SHA512}
export type ResetPromptType =
  | 0 // COMPLETE_0
  | 1 // ENTER_NO_DEVICES_1
  | 2 // ENTER_FORGOT_PW_2

export type ResetState = {readonly endTime: Time; readonly active: Boolean}
export type ResetSummary = {readonly ctime: UnixTime; readonly merkleRoot: ResetMerkleRoot; readonly resetSeqno: Seqno; readonly eldestSeqno: Seqno; readonly type: ResetType}
export type ResetType =
  | 0 // NONE_0
  | 1 // RESET_1
  | 2 // DELETE_2

export type ResolveIdentifyImplicitTeamRes = {readonly displayName: String; readonly teamID: TeamID; readonly writers?: Array<UserVersion> | null; readonly trackBreaks: {[key: string]: IdentifyTrackBreaks}; readonly folderID: TLFID}
export type RevisionSpanType =
  | 0 // DEFAULT_0
  | 1 // LAST_FIVE_1

export type RevokeWarning = {readonly endangeredTLFs?: Array<TLF> | null}
export type RevokedKey = {readonly key: PublicKey; readonly time: KeybaseTime; readonly by: KID}
export type RevokedProof = {readonly proof: RemoteProof; readonly diff: TrackDiff; readonly snoozed: Boolean}
export type RuntimeGroup =
  | 0 // UNKNOWN_0
  | 1 // LINUXLIKE_1
  | 2 // DARWINLIKE_2
  | 3 // WINDOWSLIKE_3

export type SHA512 = Bytes
export type SaltpackDecryptOptions = {readonly interactive: Boolean; readonly forceRemoteCheck: Boolean; readonly usePaperKey: Boolean}
export type SaltpackEncryptOptions = {readonly recipients?: Array<String> | null; readonly teamRecipients?: Array<String> | null; readonly authenticityType: AuthenticityType; readonly useEntityKeys: Boolean; readonly useDeviceKeys: Boolean; readonly usePaperKeys: Boolean; readonly noSelfEncrypt: Boolean; readonly binary: Boolean; readonly saltpackVersion: Int; readonly useKBFSKeysOnlyForTesting: Boolean}
export type SaltpackEncryptedMessageInfo = {readonly devices?: Array<Device> | null; readonly numAnonReceivers: Int; readonly receiverIsAnon: Boolean; readonly sender: SaltpackSender}
export type SaltpackSender = {readonly uid: UID; readonly username: String; readonly senderType: SaltpackSenderType}
export type SaltpackSenderType =
  | 0 // NOT_TRACKED_0
  | 1 // UNKNOWN_1
  | 2 // ANONYMOUS_2
  | 3 // TRACKING_BROKE_3
  | 4 // TRACKING_OK_4
  | 5 // SELF_5
  | 6 // REVOKED_6
  | 7 // EXPIRED_7

export type SaltpackSignOptions = {readonly detached: Boolean; readonly binary: Boolean; readonly saltpackVersion: Int}
export type SaltpackVerifyOptions = {readonly signedBy: String; readonly signature: Bytes}
export type SecretEntryArg = {readonly desc: String; readonly prompt: String; readonly err: String; readonly cancel: String; readonly ok: String; readonly reason: String; readonly showTyping: Boolean}
export type SecretEntryRes = {readonly text: String; readonly canceled: Boolean; readonly storeSecret: Boolean}
export type SecretKeys = {readonly signing: NaclSigningKeyPrivate; readonly encryption: NaclDHKeyPrivate}
export type SecretResponse = {readonly secret: Bytes; readonly phrase: String}
export type SeitanAKey = String
export type SeitanIKey = String
export type SeitanIKeyV2 = String
export type SeitanKeyAndLabel = {v: 1; v1: SeitanKeyAndLabelVersion1 | null} | {v: 2; v2: SeitanKeyAndLabelVersion2 | null}
export type SeitanKeyAndLabelVersion =
  | 1 // V1_1
  | 2 // V2_2

export type SeitanKeyAndLabelVersion1 = {readonly i: SeitanIKey; readonly l: SeitanKeyLabel}
export type SeitanKeyAndLabelVersion2 = {readonly k: SeitanPubKey; readonly l: SeitanKeyLabel}
export type SeitanKeyLabel = {t: 1; sms: SeitanKeyLabelSms | null}
export type SeitanKeyLabelSms = {readonly f: String; readonly n: String}
export type SeitanKeyLabelType = 1 // SMS_1

export type SeitanPubKey = KID
export type SelectKeyRes = {readonly keyID: String; readonly doSecretPush: Boolean}
export type SelectorEntry = {readonly isIndex: Boolean; readonly index: Int; readonly isKey: Boolean; readonly key: String; readonly isAll: Boolean; readonly isContents: Boolean}
export type SeqType =
  | 0 // NONE_0
  | 1 // PUBLIC_1
  | 2 // PRIVATE_2
  | 3 // SEMIPRIVATE_3

export type Seqno = Int64
export type ServiceDisplayConfig = {readonly creationDisabled: Boolean; readonly priority: Int; readonly key: String; readonly group?: String | null; readonly new: Boolean; readonly logoKey: String}
export type ServiceStatus = {readonly version: String; readonly label: String; readonly pid: String; readonly lastExitStatus: String; readonly bundleVersion: String; readonly installStatus: InstallStatus; readonly installAction: InstallAction; readonly status: Status}
export type ServicesStatus = {readonly service?: Array<ServiceStatus> | null; readonly kbfs?: Array<ServiceStatus> | null; readonly updater?: Array<ServiceStatus> | null}
export type Session = {readonly uid: UID; readonly username: String; readonly token: String; readonly deviceSubkeyKid: KID; readonly deviceSibkeyKid: KID}
export type SessionStatus = {readonly SessionFor: String; readonly Loaded: Boolean; readonly Cleared: Boolean; readonly SaltOnly: Boolean; readonly Expired: Boolean}
export type SessionToken = String
export type Sig = {readonly seqno: Seqno; readonly sigID: SigID; readonly sigIDDisplay: String; readonly type: String; readonly cTime: Time; readonly revoked: Boolean; readonly active: Boolean; readonly key: String; readonly body: String}
export type SigChainLocation = {readonly seqno: Seqno; readonly seqType: SeqType}
export type SigHint = {readonly remoteId: String; readonly humanUrl: String; readonly apiUrl: String; readonly checkText: String}
export type SigID = String
export type SigListArgs = {readonly sessionID: Int; readonly username: String; readonly allKeys: Boolean; readonly types?: SigTypes | null; readonly filterx: String; readonly verbose: Boolean; readonly revoked: Boolean}
export type SigTypes = {readonly track: Boolean; readonly proof: Boolean; readonly cryptocurrency: Boolean; readonly isSelf: Boolean}
export type SigVersion = Int
export type SignMode =
  | 0 // ATTACHED_0
  | 1 // DETACHED_1
  | 2 // CLEAR_2

export type SignatureMetadata = {readonly signingKID: KID; readonly prevMerkleRootSigned: MerkleRootV2; readonly firstAppearedUnverified: Seqno; readonly time: Time; readonly sigChainLocation: SigChainLocation}
export type SignupRes = {readonly passphraseOk: Boolean; readonly postOk: Boolean; readonly writeOk: Boolean}
export type SimpleFSGetHTTPAddressAndTokenResponse = {readonly address: String; readonly token: String}
export type SimpleFSListResult = {readonly entries?: Array<Dirent> | null; readonly progress: Progress}
export type SimpleFSQuotaUsage = {readonly usageBytes: Int64; readonly archiveBytes: Int64; readonly limitBytes: Int64; readonly gitUsageBytes: Int64; readonly gitArchiveBytes: Int64; readonly gitLimitBytes: Int64}
export type SizedImage = {readonly path: String; readonly width: Int}
export type SocialAssertion = {readonly user: String; readonly service: SocialAssertionService}
export type SocialAssertionService = String
export type StartProofResult = {readonly sigID: SigID}
export type StartStatus = {readonly log: String}
export type Status = {readonly code: Int; readonly name: String; readonly desc: String; readonly fields?: Array<StringKVPair> | null}
export type StatusCode =
  | 0 // SCOk_0
  | 100 // SCInputError_100
  | 201 // SCLoginRequired_201
  | 202 // SCBadSession_202
  | 203 // SCBadLoginUserNotFound_203
  | 204 // SCBadLoginPassword_204
  | 205 // SCNotFound_205
  | 210 // SCThrottleControl_210
  | 216 // SCDeleted_216
  | 218 // SCGeneric_218
  | 235 // SCAlreadyLoggedIn_235
  | 230 // SCExists_230
  | 237 // SCCanceled_237
  | 239 // SCInputCanceled_239
  | 243 // SCBadUsername_243
  | 267 // SCOffline_267
  | 274 // SCReloginRequired_274
  | 275 // SCResolutionFailed_275
  | 276 // SCProfileNotPublic_276
  | 277 // SCIdentifyFailed_277
  | 278 // SCTrackingBroke_278
  | 279 // SCWrongCryptoFormat_279
  | 280 // SCDecryptionError_280
  | 281 // SCInvalidAddress_281
  | 283 // SCNoSession_283
  | 290 // SCAccountReset_290
  | 295 // SCIdentifiesFailed_295
  | 297 // SCNoSpaceOnDevice_297
  | 299 // SCMerkleClientError_299
  | 472 // SCBadEmail_472
  | 602 // SCRateLimit_602
  | 701 // SCBadSignupUsernameTaken_701
  | 707 // SCBadInvitationCode_707
  | 712 // SCFeatureFlag_712
  | 801 // SCMissingResult_801
  | 901 // SCKeyNotFound_901
  | 905 // SCKeyCorrupted_905
  | 907 // SCKeyInUse_907
  | 913 // SCKeyBadGen_913
  | 914 // SCKeyNoSecret_914
  | 915 // SCKeyBadUIDs_915
  | 916 // SCKeyNoActive_916
  | 917 // SCKeyNoSig_917
  | 918 // SCKeyBadSig_918
  | 919 // SCKeyBadEldest_919
  | 920 // SCKeyNoEldest_920
  | 921 // SCKeyDuplicateUpdate_921
  | 922 // SCSibkeyAlreadyExists_922
  | 924 // SCDecryptionKeyNotFound_924
  | 927 // SCKeyNoPGPEncryption_927
  | 928 // SCKeyNoNaClEncryption_928
  | 929 // SCKeySyncedPGPNotFound_929
  | 930 // SCKeyNoMatchingGPG_930
  | 931 // SCKeyRevoked_931
  | 1002 // SCSigCannotVerify_1002
  | 1008 // SCSigWrongKey_1008
  | 1010 // SCSigOldSeqno_1010
  | 1016 // SCSigCreationDisallowed_1016
  | 1301 // SCBadTrackSession_1301
  | 1404 // SCDeviceBadName_1404
  | 1408 // SCDeviceNameInUse_1408
  | 1409 // SCDeviceNotFound_1409
  | 1410 // SCDeviceMismatch_1410
  | 1411 // SCDeviceRequired_1411
  | 1413 // SCDevicePrevProvisioned_1413
  | 1414 // SCDeviceNoProvision_1414
  | 1415 // SCDeviceProvisionViaDevice_1415
  | 1416 // SCRevokeCurrentDevice_1416
  | 1417 // SCRevokeLastDevice_1417
  | 1418 // SCDeviceProvisionOffline_1418
  | 1419 // SCRevokeLastDevicePGP_1419
  | 1501 // SCStreamExists_1501
  | 1502 // SCStreamNotFound_1502
  | 1503 // SCStreamWrongKind_1503
  | 1504 // SCStreamEOF_1504
  | 1600 // SCGenericAPIError_1600
  | 1601 // SCAPINetworkError_1601
  | 1602 // SCTimeout_1602
  | 1701 // SCProofError_1701
  | 1702 // SCIdentificationExpired_1702
  | 1703 // SCSelfNotFound_1703
  | 1704 // SCBadKexPhrase_1704
  | 1705 // SCNoUIDelegation_1705
  | 1706 // SCNoUI_1706
  | 1707 // SCGPGUnavailable_1707
  | 1800 // SCInvalidVersionError_1800
  | 1801 // SCOldVersionError_1801
  | 1802 // SCInvalidLocationError_1802
  | 1803 // SCServiceStatusError_1803
  | 1804 // SCInstallError_1804
  | 1810 // SCLoadKextError_1810
  | 1811 // SCLoadKextPermError_1811
  | 2300 // SCGitInternal_2300
  | 2301 // SCGitRepoAlreadyExists_2301
  | 2302 // SCGitInvalidRepoName_2302
  | 2303 // SCGitCannotDelete_2303
  | 2304 // SCGitRepoDoesntExist_2304
  | 2400 // SCLoginStateTimeout_2400
  | 2500 // SCChatInternal_2500
  | 2501 // SCChatRateLimit_2501
  | 2502 // SCChatConvExists_2502
  | 2503 // SCChatUnknownTLFID_2503
  | 2504 // SCChatNotInConv_2504
  | 2505 // SCChatBadMsg_2505
  | 2506 // SCChatBroadcast_2506
  | 2507 // SCChatAlreadySuperseded_2507
  | 2508 // SCChatAlreadyDeleted_2508
  | 2509 // SCChatTLFFinalized_2509
  | 2510 // SCChatCollision_2510
  | 2511 // SCIdentifySummaryError_2511
  | 2512 // SCNeedSelfRekey_2512
  | 2513 // SCNeedOtherRekey_2513
  | 2514 // SCChatMessageCollision_2514
  | 2515 // SCChatDuplicateMessage_2515
  | 2516 // SCChatClientError_2516
  | 2517 // SCChatNotInTeam_2517
  | 2518 // SCChatStalePreviousState_2518
  | 2519 // SCChatEphemeralRetentionPolicyViolatedError_2519
  | 2604 // SCTeamBadMembership_2604
  | 2607 // SCTeamSelfNotOwner_2607
  | 2614 // SCTeamNotFound_2614
  | 2619 // SCTeamExists_2619
  | 2623 // SCTeamReadError_2623
  | 2625 // SCTeamWritePermDenied_2625
  | 2638 // SCNoOp_2638
  | 2646 // SCTeamInviteBadToken_2646
  | 2663 // SCTeamTarDuplicate_2663
  | 2664 // SCTeamTarNotFound_2664
  | 2665 // SCTeamMemberExists_2665
  | 2666 // SCTeamNotReleased_2666
  | 2667 // SCTeamPermanentlyLeft_2667
  | 2668 // SCTeamNeedRootId_2668
  | 2669 // SCTeamHasLiveChildren_2669
  | 2670 // SCTeamDeleteError_2670
  | 2671 // SCTeamBadRootTeam_2671
  | 2672 // SCTeamNameConflictsWithUser_2672
  | 2673 // SCTeamDeleteNoUpPointer_2673
  | 2674 // SCTeamNeedOwner_2674
  | 2675 // SCTeamNoOwnerAllowed_2675
  | 2676 // SCTeamImplicitNoNonSbs_2676
  | 2677 // SCTeamImplicitBadHash_2677
  | 2678 // SCTeamImplicitBadName_2678
  | 2679 // SCTeamImplicitClash_2679
  | 2680 // SCTeamImplicitDuplicate_2680
  | 2681 // SCTeamImplicitBadOp_2681
  | 2682 // SCTeamImplicitBadRole_2682
  | 2683 // SCTeamImplicitNotFound_2683
  | 2684 // SCTeamBadAdminSeqnoType_2684
  | 2685 // SCTeamImplicitBadAdd_2685
  | 2686 // SCTeamImplicitBadRemove_2686
  | 2696 // SCTeamInviteTokenReused_2696
  | 2697 // SCTeamKeyMaskNotFound_2697
  | 2702 // SCTeamBanned_2702
  | 2703 // SCTeamInvalidBan_2703
  | 2711 // SCTeamShowcasePermDenied_2711
  | 2721 // SCTeamProvisionalCanKey_2721
  | 2722 // SCTeamProvisionalCannotKey_2722
  | 2736 // SCTeamFTLOutdated_2736
  | 2900 // SCEphemeralKeyBadGeneration_2900
  | 2901 // SCEphemeralKeyUnexpectedBox_2901
  | 2902 // SCEphemeralKeyMissingBox_2902
  | 2903 // SCEphemeralKeyWrongNumberOfKeys_2903
  | 2904 // SCEphemeralKeyMismatchedKey_2904
  | 2905 // SCEphemeralPairwiseMACsMissingUIDs_2905
  | 2906 // SCEphemeralDeviceAfterEK_2906
  | 2907 // SCEphemeralMemberAfterEK_2907
  | 2908 // SCEphemeralDeviceStale_2908
  | 2909 // SCEphemeralUserStale_2909
  | 3100 // SCStellarError_3100
  | 3101 // SCStellarBadInput_3101
  | 3102 // SCStellarWrongRevision_3102
  | 3103 // SCStellarMissingBundle_3103
  | 3104 // SCStellarBadPuk_3104
  | 3105 // SCStellarMissingAccount_3105
  | 3106 // SCStellarBadPrev_3106
  | 3107 // SCStellarWrongPrimary_3107
  | 3108 // SCStellarUnsupportedCurrency_3108
  | 3109 // SCStellarNeedDisclaimer_3109
  | 3110 // SCStellarDeviceNotMobile_3110
  | 3111 // SCStellarMobileOnlyPurgatory_3111
  | 3112 // SCStellarIncompatibleVersion_3112
  | 3201 // SCNISTWrongSize_3201
  | 3202 // SCNISTBadMode_3202
  | 3203 // SCNISTHashWrongSize_3203
  | 3204 // SCNISTSigWrongSize_3204
  | 3205 // SCNISTSigBadInput_3205
  | 3206 // SCNISTSigBadUID_3206
  | 3207 // SCNISTSigBadDeviceID_3207
  | 3208 // SCNISTSigBadNonce_3208
  | 3209 // SCNISTNoSigOrHash_3209
  | 3210 // SCNISTExpired_3210
  | 3211 // SCNISTSigRevoked_3211
  | 3212 // SCNISTKeyRevoked_3212
  | 3213 // SCNISTUserDeleted_3213
  | 3214 // SCNISTNoDevice_3214
  | 3215 // SCNISTSigCannot_verify_3215
  | 3216 // SCNISTReplay_3216
  | 3217 // SCNISTSigBadLifetime_3217
  | 3218 // SCNISTNotFound_3218
  | 3219 // SCNISTBadClock_3219
  | 3220 // SCNISTSigBadCtime_3220
  | 3221 // SCBadSignupUsernameDeleted_3221
  | 3605 // SCNoPaperKeys_3605

export type StellarAccount = {readonly accountID: String; readonly federationAddress: String; readonly sigID: SigID}
export type Stream = {readonly fd: Int}
export type StringKVPair = {readonly key: String; readonly value: String}
export type SubteamListEntry = {readonly name: TeamName; readonly memberCount: Int}
export type SubteamListResult = {readonly entries?: Array<SubteamListEntry> | null}
export type SubteamLogPoint = {readonly name: TeamName; readonly seqno: Seqno}
export type SyncConfigAndStatusRes = {readonly folders?: Array<FolderSyncConfigAndStatusWithFolder> | null; readonly overallStatus: FolderSyncStatus}
export type TLF = {readonly id: TLFID; readonly name: String; readonly writers?: Array<String> | null; readonly readers?: Array<String> | null; readonly isPrivate: Boolean}
export type TLFBreak = {readonly breaks?: Array<TLFIdentifyFailure> | null}
export type TLFID = String
export type TLFIdentifyBehavior =
  | 0 // UNSET_0
  | 1 // CHAT_CLI_1
  | 2 // CHAT_GUI_2
  | 3 // REMOVED_AND_UNUSED_3
  | 4 // KBFS_REKEY_4
  | 5 // KBFS_QR_5
  | 6 // CHAT_SKIP_6
  | 7 // SALTPACK_7
  | 8 // CLI_8
  | 9 // GUI_9
  | 10 // DEFAULT_KBFS_10
  | 11 // KBFS_CHAT_11
  | 12 // RESOLVE_AND_CHECK_12
  | 13 // GUI_PROFILE_13
  | 14 // KBFS_INIT_14

export type TLFIdentifyFailure = {readonly user: User; readonly breaks?: IdentifyTrackBreaks | null}
export type TLFQuery = {readonly tlfName: String; readonly identifyBehavior: TLFIdentifyBehavior}
export type TLFVisibility =
  | 0 // ANY_0
  | 1 // PUBLIC_1
  | 2 // PRIVATE_2

export type TeamAcceptOrRequestResult = {readonly wasToken: Boolean; readonly wasSeitan: Boolean; readonly wasTeamName: Boolean; readonly wasOpenTeam: Boolean}
export type TeamAccessRequest = {readonly uid: UID; readonly eldestSeqno: Seqno}
export type TeamAddMemberResult = {readonly invited: Boolean; readonly user?: User | null; readonly emailSent: Boolean; readonly chatSending: Boolean}
export type TeamAndMemberShowcase = {readonly teamShowcase: TeamShowcase; readonly isMemberShowcased: Boolean}
export type TeamApplication =
  | 1 // KBFS_1
  | 2 // CHAT_2
  | 3 // SALTPACK_3
  | 4 // GIT_METADATA_4
  | 5 // SEITAN_INVITE_TOKEN_5
  | 6 // STELLAR_RELAY_6

export type TeamApplicationKey = {readonly application: TeamApplication; readonly keyGeneration: PerTeamKeyGeneration; readonly key: Bytes32}
export type TeamCLKRMsg = {readonly teamID: TeamID; readonly generation: PerTeamKeyGeneration; readonly score: Int; readonly resetUsersUntrusted?: Array<TeamCLKRResetUser> | null}
export type TeamCLKRResetUser = {readonly uid: UID; readonly userEldestSeqno: Seqno; readonly memberEldestSeqno: Seqno}
export type TeamChangeReq = {readonly owners?: Array<UserVersion> | null; readonly admins?: Array<UserVersion> | null; readonly writers?: Array<UserVersion> | null; readonly readers?: Array<UserVersion> | null; readonly none?: Array<UserVersion> | null; readonly completedInvites: {[key: string]: UserVersionPercentForm}}
export type TeamChangeRow = {readonly id: TeamID; readonly name: String; readonly keyRotated: Boolean; readonly membershipChanged: Boolean; readonly latestSeqno: Seqno; readonly implicitTeam: Boolean; readonly misc: Boolean; readonly removedResetUsers: Boolean}
export type TeamChangeSet = {readonly membershipChanged: Boolean; readonly keyRotated: Boolean; readonly renamed: Boolean; readonly misc: Boolean}
export type TeamCreateResult = {readonly teamID: TeamID; readonly chatSent: Boolean; readonly creatorAdded: Boolean}
export type TeamData = {readonly v: /* subversion */ Int; readonly frozen: Boolean; readonly tombstoned: Boolean; readonly secretless: Boolean; readonly name: TeamName; readonly chain: TeamSigChainState; readonly perTeamKeySeeds: /* perTeamKeySeedsUnverified */ {[key: string]: PerTeamKeySeedItem}; readonly readerKeyMasks: {[key: string]: {[key: string]: MaskB64}}; readonly latestSeqnoHint: Seqno; readonly cachedAt: Time; readonly tlfCryptKeys: {[key: string]: Array<CryptKey> | null}}
export type TeamDebugRes = {readonly chain: TeamSigChainState}
export type TeamDetails = {readonly members: TeamMembersDetails; readonly keyGeneration: PerTeamKeyGeneration; readonly annotatedActiveInvites: {[key: string]: AnnotatedTeamInvite}; readonly settings: TeamSettings; readonly showcase: TeamShowcase}
export type TeamEk = {readonly seed: Bytes32; readonly metadata: TeamEkMetadata}
export type TeamEkBoxMetadata = {readonly box: String; readonly recipientGeneration: EkGeneration; readonly recipientUID: UID}
export type TeamEkBoxed = {readonly box: String; readonly userEkGeneration: EkGeneration; readonly metadata: TeamEkMetadata}
export type TeamEkMetadata = {readonly kid: KID; readonly hashMeta: HashMeta; readonly generation: EkGeneration; readonly ctime: Time}
export type TeamEkStatement = {readonly currentTeamEkMetadata: TeamEkMetadata}
export type TeamEncryptedKBFSKeyset = {readonly v: Int; readonly e: Bytes; readonly n: Bytes}
export type TeamEncryptedKBFSKeysetHash = String
export type TeamExitRow = {readonly id: TeamID}
export type TeamGetLegacyTLFUpgrade = {readonly encryptedKeyset: String; readonly teamGeneration: PerTeamKeyGeneration; readonly legacyGeneration: Int; readonly appType: TeamApplication}
export type TeamID = String
export type TeamIDAndName = {readonly id: TeamID; readonly name: TeamName}
export type TeamIDWithVisibility = {readonly teamID: TeamID; readonly visibility: TLFVisibility}
export type TeamInvite = {readonly role: TeamRole; readonly id: TeamInviteID; readonly type: TeamInviteType; readonly name: TeamInviteName; readonly inviter: UserVersion}
export type TeamInviteCategory =
  | 0 // NONE_0
  | 1 // UNKNOWN_1
  | 2 // KEYBASE_2
  | 3 // EMAIL_3
  | 4 // SBS_4
  | 5 // SEITAN_5
  | 6 // PHONE_6

export type TeamInviteID = String
export type TeamInviteName = String
export type TeamInviteSocialNetwork = String
export type TeamInviteType = {c: 1; unknown: String | null} | {c: 4; sbs: TeamInviteSocialNetwork | null}
export type TeamInvitee = {readonly inviteID: TeamInviteID; readonly uid: UID; readonly eldestSeqno: Seqno; readonly role: TeamRole}
export type TeamJoinRequest = {readonly name: String; readonly username: String}
export type TeamKBFSKeyRefresher = {readonly generation: Int; readonly appType: TeamApplication}
export type TeamLegacyTLFUpgradeChainInfo = {readonly keysetHash: TeamEncryptedKBFSKeysetHash; readonly teamGeneration: PerTeamKeyGeneration; readonly legacyGeneration: Int; readonly appType: TeamApplication}
export type TeamList = {readonly teams?: Array<MemberInfo> | null}
export type TeamMember = {readonly uid: UID; readonly role: TeamRole; readonly eldestSeqno: Seqno; readonly status: TeamMemberStatus}
export type TeamMemberDetails = {readonly uv: UserVersion; readonly username: String; readonly fullName: FullName; readonly needsPUK: Boolean; readonly status: TeamMemberStatus}
export type TeamMemberOutFromReset = {readonly teamName: String; readonly resetUser: TeamResetUser}
export type TeamMemberOutReset = {readonly teamname: String; readonly username: String; readonly uid: UID; readonly id: Gregor1.MsgID}
export type TeamMemberStatus =
  | 0 // ACTIVE_0
  | 1 // RESET_1
  | 2 // DELETED_2

export type TeamMembers = {readonly owners?: Array<UserVersion> | null; readonly admins?: Array<UserVersion> | null; readonly writers?: Array<UserVersion> | null; readonly readers?: Array<UserVersion> | null}
export type TeamMembersDetails = {readonly owners?: Array<TeamMemberDetails> | null; readonly admins?: Array<TeamMemberDetails> | null; readonly writers?: Array<TeamMemberDetails> | null; readonly readers?: Array<TeamMemberDetails> | null}
export type TeamName = {readonly parts?: Array<TeamNamePart> | null}
export type TeamNameLogPoint = {readonly lastPart: TeamNamePart; readonly seqno: Seqno}
export type TeamNamePart = String
export type TeamNewlyAddedRow = {readonly id: TeamID; readonly name: String}
export type TeamOpenReqMsg = {readonly teamID: TeamID; readonly tars?: Array<TeamAccessRequest> | null}
export type TeamOpenSweepMsg = {readonly teamID: TeamID; readonly resetUsersUntrusted?: Array<TeamCLKRResetUser> | null}
export type TeamOperation = {readonly manageMembers: Boolean; readonly manageSubteams: Boolean; readonly createChannel: Boolean; readonly chat: Boolean; readonly deleteChannel: Boolean; readonly renameChannel: Boolean; readonly editChannelDescription: Boolean; readonly editTeamDescription: Boolean; readonly setTeamShowcase: Boolean; readonly setMemberShowcase: Boolean; readonly setRetentionPolicy: Boolean; readonly setMinWriterRole: Boolean; readonly changeOpenTeam: Boolean; readonly leaveTeam: Boolean; readonly joinTeam: Boolean; readonly setPublicityAny: Boolean; readonly listFirst: Boolean; readonly changeTarsDisabled: Boolean; readonly deleteChatHistory: Boolean; readonly deleteOtherMessages: Boolean; readonly deleteTeam: Boolean}
export type TeamPlusApplicationKeys = {readonly id: TeamID; readonly name: String; readonly implicit: Boolean; readonly public: Boolean; readonly application: TeamApplication; readonly writers?: Array<UserVersion> | null; readonly onlyReaders?: Array<UserVersion> | null; readonly applicationKeys?: Array<TeamApplicationKey> | null}
export type TeamProfileAddEntry = {readonly teamName: TeamName; readonly open: Boolean; readonly disabledReason: String}
export type TeamRefreshers = {readonly needKeyGeneration: PerTeamKeyGeneration; readonly needApplicationsAtGenerations: {[key: string]: Array<TeamApplication> | null}; readonly needApplicationsAtGenerationsWithKBFS: {[key: string]: Array<TeamApplication> | null}; readonly wantMembers?: Array<UserVersion> | null; readonly wantMembersRole: TeamRole; readonly needKBFSKeyGeneration: TeamKBFSKeyRefresher}
export type TeamRequestAccessResult = {readonly open: Boolean}
export type TeamResetUser = {readonly username: String; readonly uid: UID; readonly eldestSeqno: Seqno; readonly isDelete: Boolean}
export type TeamRole =
  | 0 // NONE_0
  | 1 // READER_1
  | 2 // WRITER_2
  | 3 // ADMIN_3
  | 4 // OWNER_4

export type TeamSBSMsg = {readonly teamID: TeamID; readonly score: Int; readonly invitees?: Array<TeamInvitee> | null}
export type TeamSeitanMsg = {readonly teamID: TeamID; readonly seitans?: Array<TeamSeitanRequest> | null}
export type TeamSeitanRequest = {readonly inviteID: TeamInviteID; readonly uid: UID; readonly eldestSeqno: Seqno; readonly akey: SeitanAKey; readonly role: TeamRole; readonly unixCTime: Int64}
export type TeamSettings = {readonly open: Boolean; readonly joinAs: TeamRole}
export type TeamShowcase = {readonly isShowcased: Boolean; readonly description?: String | null; readonly setByUID?: UID | null; readonly anyMemberShowcase: Boolean}
export type TeamSigChainState = {readonly reader: UserVersion; readonly id: TeamID; readonly implicit: Boolean; readonly public: Boolean; readonly rootAncestor: TeamName; readonly nameDepth: Int; readonly nameLog?: Array<TeamNameLogPoint> | null; readonly lastSeqno: Seqno; readonly lastLinkID: LinkID; readonly lastHighSeqno: Seqno; readonly lastHighLinkID: LinkID; readonly parentID?: TeamID | null; readonly userLog: {[key: string]: Array<UserLogPoint> | null}; readonly subteamLog: {[key: string]: Array<SubteamLogPoint> | null}; readonly perTeamKeys: {[key: string]: PerTeamKey}; readonly perTeamKeyCTime: UnixTime; readonly linkIDs: {[key: string]: LinkID}; readonly stubbedLinks: {[key: string]: Boolean}; readonly activeInvites: {[key: string]: TeamInvite}; readonly obsoleteInvites: {[key: string]: TeamInvite}; readonly open: Boolean; readonly openTeamJoinAs: TeamRole; readonly tlfIDs?: Array<TLFID> | null; readonly tlfLegacyUpgrade: {[key: string]: TeamLegacyTLFUpgradeChainInfo}; readonly headMerkle?: MerkleRootV2 | null; readonly merkleRoots: {[key: string]: MerkleRootV2}}
export type TeamStatus =
  | 0 // NONE_0
  | 1 // LIVE_1
  | 2 // DELETED_2
  | 3 // ABANDONED_3

export type TeamTreeEntry = {readonly name: TeamName; readonly admin: Boolean}
export type TeamTreeResult = {readonly entries?: Array<TeamTreeEntry> | null}
export type TeamType =
  | 0 // NONE_0
  | 1 // LEGACY_1
  | 2 // MODERN_2

export type Test = {readonly reply: String}
export type Text = {readonly data: String; readonly markup: Boolean}
export type Time = Long
export type TrackDiff = {readonly type: TrackDiffType; readonly displayMarkup: String}
export type TrackDiffType =
  | 0 // NONE_0
  | 1 // ERROR_1
  | 2 // CLASH_2
  | 3 // REVOKED_3
  | 4 // UPGRADED_4
  | 5 // NEW_5
  | 6 // REMOTE_FAIL_6
  | 7 // REMOTE_WORKING_7
  | 8 // REMOTE_CHANGED_8
  | 9 // NEW_ELDEST_9
  | 10 // NONE_VIA_TEMPORARY_10

export type TrackOptions = {readonly localOnly: Boolean; readonly bypassConfirm: Boolean; readonly forceRetrack: Boolean; readonly expiringLocal: Boolean; readonly forPGPPull: Boolean; readonly sigVersion?: SigVersion | null}
export type TrackProof = {readonly proofType: String; readonly proofName: String; readonly idString: String}
export type TrackStatus =
  | 1 // NEW_OK_1
  | 2 // NEW_ZERO_PROOFS_2
  | 3 // NEW_FAIL_PROOFS_3
  | 4 // UPDATE_BROKEN_FAILED_PROOFS_4
  | 5 // UPDATE_NEW_PROOFS_5
  | 6 // UPDATE_OK_6
  | 7 // UPDATE_BROKEN_REVOKED_7

export type TrackSummary = {readonly username: String; readonly time: Time; readonly isRemote: Boolean}
export type TrackToken = String
export type Tracker = {readonly tracker: UID; readonly status: Int; readonly mTime: Time}
export type UID = String
export type UPAKVersion =
  | 1 // V1_1
  | 2 // V2_2

export type UPAKVersioned = {v: 1; v1: UserPlusAllKeys | null} | {v: 2; v2: UserPlusKeysV2AllIncarnations | null}
export type UPK2MinorVersion =
  | 0 // V0_0
  | 1 // V1_1
  | 2 // V2_2
  | 3 // V3_3
  | 4 // V4_4
  | 5 // V5_5
  | 6 // V6_6

export type UPKLiteMinorVersion = 0 // V0_0

export type UPKLiteV1 = {readonly uid: UID; readonly username: String; readonly eldestSeqno: Seqno; readonly status: StatusCode; readonly deviceKeys: {[key: string]: PublicKeyV2NaCl}; readonly reset?: ResetSummary | null}
export type UPKLiteV1AllIncarnations = {readonly current: UPKLiteV1; readonly pastIncarnations?: Array<UPKLiteV1> | null; readonly seqnoLinkIDs: {[key: string]: LinkID}; readonly minorVersion: UPKLiteMinorVersion}
export type UnboxAnyRes = {readonly kid: KID; readonly plaintext: Bytes32; readonly index: Int}
export type UninstallResult = {readonly componentResults?: Array<ComponentResult> | null; readonly status: Status}
export type UnixTime = Long
export type UpPointer = {readonly ourSeqno: Seqno; readonly parentID: TeamID; readonly parentSeqno: Seqno; readonly deletion: Boolean}
export type UpdateDetails = {readonly message: String}
export type UpdateInfo = {readonly status: UpdateInfoStatus; readonly message: String}
export type UpdateInfo2 = {status: 0} | {status: 1; suggested: UpdateDetails | null} | {status: 2; critical: UpdateDetails | null}
export type UpdateInfoStatus =
  | 0 // UP_TO_DATE_0
  | 1 // NEED_UPDATE_1
  | 2 // CRITICALLY_OUT_OF_DATE_2

export type UpdateInfoStatus2 =
  | 0 // OK_0
  | 1 // SUGGESTED_1
  | 2 // CRITICAL_2

export type UpdaterStatus = {readonly log: String}
export type User = {readonly uid: UID; readonly username: String}
export type UserCard = {readonly following: Int; readonly followers: Int; readonly uid: UID; readonly fullName: String; readonly location: String; readonly bio: String; readonly website: String; readonly twitter: String; readonly youFollowThem: Boolean; readonly theyFollowYou: Boolean; readonly teamShowcase?: Array<UserTeamShowcase> | null; readonly registeredForAirdrop: Boolean}
export type UserEk = {readonly seed: Bytes32; readonly metadata: UserEkMetadata}
export type UserEkBoxMetadata = {readonly box: String; readonly recipientGeneration: EkGeneration; readonly recipientDeviceID: DeviceID}
export type UserEkBoxed = {readonly box: String; readonly deviceEkGeneration: EkGeneration; readonly metadata: UserEkMetadata}
export type UserEkMetadata = {readonly kid: KID; readonly hashMeta: HashMeta; readonly generation: EkGeneration; readonly ctime: Time}
export type UserEkReboxArg = {readonly userEkBoxMetadata: UserEkBoxMetadata; readonly deviceID: DeviceID; readonly deviceEkStatementSig: String}
export type UserEkStatement = {readonly currentUserEkMetadata: UserEkMetadata}
export type UserLogPoint = {readonly role: TeamRole; readonly sigMeta: SignatureMetadata}
export type UserOrTeamID = String
export type UserOrTeamLite = {readonly id: UserOrTeamID; readonly name: String}
export type UserOrTeamResult =
  | 1 // USER_1
  | 2 // TEAM_2

export type UserPhoneNumber = {readonly phoneNumber: PhoneNumber; readonly verified: Boolean; readonly visibility: IdentityVisibility; readonly ctime: UnixTime}
export type UserPlusAllKeys = {readonly base: UserPlusKeys; readonly pgpKeys?: Array<PublicKey> | null; readonly remoteTracks?: Array<RemoteTrack> | null}
export type UserPlusKeys = {readonly uid: UID; readonly username: String; readonly eldestSeqno: Seqno; readonly status: StatusCode; readonly deviceKeys?: Array<PublicKey> | null; readonly revokedDeviceKeys?: Array<RevokedKey> | null; readonly pgpKeyCount: Int; readonly uvv: UserVersionVector; readonly deletedDeviceKeys?: Array<PublicKey> | null; readonly perUserKeys?: Array<PerUserKey> | null; readonly resets?: Array<ResetSummary> | null}
export type UserPlusKeysV2 = {readonly uid: UID; readonly username: String; readonly eldestSeqno: Seqno; readonly status: StatusCode; readonly perUserKeys?: Array<PerUserKey> | null; readonly deviceKeys: {[key: string]: PublicKeyV2NaCl}; readonly pgpKeys: {[key: string]: PublicKeyV2PGPSummary}; readonly stellarAccountID?: String | null; readonly remoteTracks: {[key: string]: RemoteTrack}; readonly reset?: ResetSummary | null; readonly unstubbed: Boolean}
export type UserPlusKeysV2AllIncarnations = {readonly current: UserPlusKeysV2; readonly pastIncarnations?: Array<UserPlusKeysV2> | null; readonly uvv: UserVersionVector; readonly seqnoLinkIDs: {[key: string]: LinkID}; readonly minorVersion: UPK2MinorVersion}
export type UserReacjis = {readonly topReacjis?: Array<String> | null; readonly skinTone: ReacjiSkinTone}
export type UserRolePair = {readonly assertionOrEmail: String; readonly role: TeamRole}
export type UserSettings = {readonly emails?: Array<Email> | null}
export type UserSummary = {readonly uid: UID; readonly username: String; readonly thumbnail: String; readonly idVersion: Int; readonly fullName: String; readonly bio: String; readonly proofs: Proofs; readonly sigIDDisplay: String; readonly trackTime: Time}
export type UserSummary2 = {readonly uid: UID; readonly username: String; readonly thumbnail: String; readonly fullName: String; readonly isFollower: Boolean; readonly isFollowee: Boolean}
export type UserSummary2Set = {readonly users?: Array<UserSummary2> | null; readonly time: Time; readonly version: Int}
export type UserTeamShowcase = {readonly fqName: String; readonly open: Boolean; readonly teamIsShowcased: Boolean; readonly description: String; readonly role: TeamRole; readonly publicAdmins?: Array<String> | null; readonly numMembers: Int}
export type UserVersion = {readonly uid: UID; readonly eldestSeqno: Seqno}
export type UserVersionPercentForm = String
export type UserVersionVector = {readonly id: Long; readonly sigHints: Int; readonly sigChain: Long; readonly cachedAt: Time}
export type VerifySessionRes = {readonly uid: UID; readonly sid: String; readonly generated: Int; readonly lifetime: Int}
export type WalletAccountInfo = {readonly accountID: String; readonly numUnread: Int}
export type WebProof = {readonly hostname: String; readonly protocols?: Array<String> | null}
export type WriteArgs = {readonly opID: OpID; readonly path: Path; readonly offset: Long}

export type IncomingCallMapType = {
  'keybase.1.gpgUi.wantToAddGPGKey'?: (params: MessageTypes['keybase.1.gpgUi.wantToAddGPGKey']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gpgUi.confirmDuplicateKeyChosen'?: (params: MessageTypes['keybase.1.gpgUi.confirmDuplicateKeyChosen']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gpgUi.confirmImportSecretToExistingKey'?: (params: MessageTypes['keybase.1.gpgUi.confirmImportSecretToExistingKey']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gpgUi.selectKeyAndPushOption'?: (params: MessageTypes['keybase.1.gpgUi.selectKeyAndPushOption']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gpgUi.selectKey'?: (params: MessageTypes['keybase.1.gpgUi.selectKey']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gpgUi.sign'?: (params: MessageTypes['keybase.1.gpgUi.sign']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gpgUi.getTTY'?: (params: MessageTypes['keybase.1.gpgUi.getTTY']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gregorUI.pushState'?: (params: MessageTypes['keybase.1.gregorUI.pushState']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.gregorUI.pushOutOfBandMessages'?: (params: MessageTypes['keybase.1.gregorUI.pushOutOfBandMessages']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.homeUI.homeUIRefresh'?: (params: MessageTypes['keybase.1.homeUI.homeUIRefresh']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identify3Ui.identify3ShowTracker'?: (params: MessageTypes['keybase.1.identify3Ui.identify3ShowTracker']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identify3Ui.identify3UpdateRow'?: (params: MessageTypes['keybase.1.identify3Ui.identify3UpdateRow']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identify3Ui.identify3UserReset'?: (params: MessageTypes['keybase.1.identify3Ui.identify3UserReset']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identify3Ui.identify3UpdateUserCard'?: (params: MessageTypes['keybase.1.identify3Ui.identify3UpdateUserCard']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identify3Ui.identify3TrackerTimedOut'?: (params: MessageTypes['keybase.1.identify3Ui.identify3TrackerTimedOut']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identify3Ui.identify3Result'?: (params: MessageTypes['keybase.1.identify3Ui.identify3Result']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.displayTLFCreateWithInvite'?: (params: MessageTypes['keybase.1.identifyUi.displayTLFCreateWithInvite']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.delegateIdentifyUI'?: (params: MessageTypes['keybase.1.identifyUi.delegateIdentifyUI']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.start'?: (params: MessageTypes['keybase.1.identifyUi.start']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.displayKey'?: (params: MessageTypes['keybase.1.identifyUi.displayKey']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.reportLastTrack'?: (params: MessageTypes['keybase.1.identifyUi.reportLastTrack']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.launchNetworkChecks'?: (params: MessageTypes['keybase.1.identifyUi.launchNetworkChecks']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.displayTrackStatement'?: (params: MessageTypes['keybase.1.identifyUi.displayTrackStatement']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.finishWebProofCheck'?: (params: MessageTypes['keybase.1.identifyUi.finishWebProofCheck']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.finishSocialProofCheck'?: (params: MessageTypes['keybase.1.identifyUi.finishSocialProofCheck']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.displayCryptocurrency'?: (params: MessageTypes['keybase.1.identifyUi.displayCryptocurrency']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.displayStellarAccount'?: (params: MessageTypes['keybase.1.identifyUi.displayStellarAccount']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.reportTrackToken'?: (params: MessageTypes['keybase.1.identifyUi.reportTrackToken']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.displayUserCard'?: (params: MessageTypes['keybase.1.identifyUi.displayUserCard']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.confirm'?: (params: MessageTypes['keybase.1.identifyUi.confirm']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.cancel'?: (params: MessageTypes['keybase.1.identifyUi.cancel']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.finish'?: (params: MessageTypes['keybase.1.identifyUi.finish']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.identifyUi.dismiss'?: (params: MessageTypes['keybase.1.identifyUi.dismiss']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.logUi.log'?: (params: MessageTypes['keybase.1.logUi.log']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.getEmailOrUsername'?: (params: MessageTypes['keybase.1.loginUi.getEmailOrUsername']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.promptRevokePaperKeys'?: (params: MessageTypes['keybase.1.loginUi.promptRevokePaperKeys']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.displayPaperKeyPhrase'?: (params: MessageTypes['keybase.1.loginUi.displayPaperKeyPhrase']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.displayPrimaryPaperKey'?: (params: MessageTypes['keybase.1.loginUi.displayPrimaryPaperKey']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.promptResetAccount'?: (params: MessageTypes['keybase.1.loginUi.promptResetAccount']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.displayResetProgress'?: (params: MessageTypes['keybase.1.loginUi.displayResetProgress']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.explainDeviceRecovery'?: (params: MessageTypes['keybase.1.loginUi.explainDeviceRecovery']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.loginUi.promptPassphraseRecovery'?: (params: MessageTypes['keybase.1.loginUi.promptPassphraseRecovery']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.logsend.prepareLogsend'?: (params: MessageTypes['keybase.1.logsend.prepareLogsend']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyApp.exit'?: (params: MessageTypes['keybase.1.NotifyApp.exit']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyAudit.rootAuditError'?: (params: MessageTypes['keybase.1.NotifyAudit.rootAuditError']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyAudit.boxAuditError'?: (params: MessageTypes['keybase.1.NotifyAudit.boxAuditError']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyBadges.badgeState'?: (params: MessageTypes['keybase.1.NotifyBadges.badgeState']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyCanUserPerform.canUserPerformChanged'?: (params: MessageTypes['keybase.1.NotifyCanUserPerform.canUserPerformChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyDeviceClone.deviceCloneCountChanged'?: (params: MessageTypes['keybase.1.NotifyDeviceClone.deviceCloneCountChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyEmailAddress.emailAddressVerified'?: (params: MessageTypes['keybase.1.NotifyEmailAddress.emailAddressVerified']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyEphemeral.newTeamEk'?: (params: MessageTypes['keybase.1.NotifyEphemeral.newTeamEk']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFavorites.favoritesChanged'?: (params: MessageTypes['keybase.1.NotifyFavorites.favoritesChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSActivity'?: (params: MessageTypes['keybase.1.NotifyFS.FSActivity']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSPathUpdated'?: (params: MessageTypes['keybase.1.NotifyFS.FSPathUpdated']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSSyncActivity'?: (params: MessageTypes['keybase.1.NotifyFS.FSSyncActivity']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSEditListResponse'?: (params: MessageTypes['keybase.1.NotifyFS.FSEditListResponse']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSSyncStatusResponse'?: (params: MessageTypes['keybase.1.NotifyFS.FSSyncStatusResponse']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSOverallSyncStatusChanged'?: (params: MessageTypes['keybase.1.NotifyFS.FSOverallSyncStatusChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSFavoritesChanged'?: (params: MessageTypes['keybase.1.NotifyFS.FSFavoritesChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyFS.FSOnlineStatusChanged'?: (params: MessageTypes['keybase.1.NotifyFS.FSOnlineStatusChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyKeyfamily.keyfamilyChanged'?: (params: MessageTypes['keybase.1.NotifyKeyfamily.keyfamilyChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyPaperKey.paperKeyCached'?: (params: MessageTypes['keybase.1.NotifyPaperKey.paperKeyCached']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyPGP.pgpKeyInSecretStoreFile'?: (params: MessageTypes['keybase.1.NotifyPGP.pgpKeyInSecretStoreFile']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyPhoneNumber.phoneNumberAdded'?: (params: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberAdded']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyPhoneNumber.phoneNumberVerified'?: (params: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberVerified']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyPhoneNumber.phoneNumberSuperseded'?: (params: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberSuperseded']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyService.shutdown'?: (params: MessageTypes['keybase.1.NotifyService.shutdown']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifySession.loggedOut'?: (params: MessageTypes['keybase.1.NotifySession.loggedOut']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifySession.loggedIn'?: (params: MessageTypes['keybase.1.NotifySession.loggedIn']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifySession.clientOutOfDate'?: (params: MessageTypes['keybase.1.NotifySession.clientOutOfDate']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.teamChangedByID'?: (params: MessageTypes['keybase.1.NotifyTeam.teamChangedByID']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.teamChangedByName'?: (params: MessageTypes['keybase.1.NotifyTeam.teamChangedByName']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.teamDeleted'?: (params: MessageTypes['keybase.1.NotifyTeam.teamDeleted']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.teamAbandoned'?: (params: MessageTypes['keybase.1.NotifyTeam.teamAbandoned']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.teamExit'?: (params: MessageTypes['keybase.1.NotifyTeam.teamExit']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.newlyAddedToTeam'?: (params: MessageTypes['keybase.1.NotifyTeam.newlyAddedToTeam']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTeam.avatarUpdated'?: (params: MessageTypes['keybase.1.NotifyTeam.avatarUpdated']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyTracking.trackingChanged'?: (params: MessageTypes['keybase.1.NotifyTracking.trackingChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyUnverifiedTeamList.teamListUnverifiedChanged'?: (params: MessageTypes['keybase.1.NotifyUnverifiedTeamList.teamListUnverifiedChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyUsers.userChanged'?: (params: MessageTypes['keybase.1.NotifyUsers.userChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.NotifyUsers.passwordChanged'?: (params: MessageTypes['keybase.1.NotifyUsers.passwordChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.pgpUi.outputSignatureSuccess'?: (params: MessageTypes['keybase.1.pgpUi.outputSignatureSuccess']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.pgpUi.outputSignatureSuccessNonKeybase'?: (params: MessageTypes['keybase.1.pgpUi.outputSignatureSuccessNonKeybase']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.pgpUi.keyGenerated'?: (params: MessageTypes['keybase.1.pgpUi.keyGenerated']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.pgpUi.shouldPushPrivate'?: (params: MessageTypes['keybase.1.pgpUi.shouldPushPrivate']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.pgpUi.finished'?: (params: MessageTypes['keybase.1.pgpUi.finished']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.promptOverwrite'?: (params: MessageTypes['keybase.1.proveUi.promptOverwrite']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.promptUsername'?: (params: MessageTypes['keybase.1.proveUi.promptUsername']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.outputPrechecks'?: (params: MessageTypes['keybase.1.proveUi.outputPrechecks']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.preProofWarning'?: (params: MessageTypes['keybase.1.proveUi.preProofWarning']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.outputInstructions'?: (params: MessageTypes['keybase.1.proveUi.outputInstructions']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.okToCheck'?: (params: MessageTypes['keybase.1.proveUi.okToCheck']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.checking'?: (params: MessageTypes['keybase.1.proveUi.checking']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.continueChecking'?: (params: MessageTypes['keybase.1.proveUi.continueChecking']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.proveUi.displayRecheckWarning'?: (params: MessageTypes['keybase.1.proveUi.displayRecheckWarning']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.chooseProvisioningMethod'?: (params: MessageTypes['keybase.1.provisionUi.chooseProvisioningMethod']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.chooseGPGMethod'?: (params: MessageTypes['keybase.1.provisionUi.chooseGPGMethod']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.switchToGPGSignOK'?: (params: MessageTypes['keybase.1.provisionUi.switchToGPGSignOK']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.chooseDevice'?: (params: MessageTypes['keybase.1.provisionUi.chooseDevice']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.chooseDeviceType'?: (params: MessageTypes['keybase.1.provisionUi.chooseDeviceType']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.DisplayAndPromptSecret'?: (params: MessageTypes['keybase.1.provisionUi.DisplayAndPromptSecret']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.DisplaySecretExchanged'?: (params: MessageTypes['keybase.1.provisionUi.DisplaySecretExchanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.PromptNewDeviceName'?: (params: MessageTypes['keybase.1.provisionUi.PromptNewDeviceName']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.ProvisioneeSuccess'?: (params: MessageTypes['keybase.1.provisionUi.ProvisioneeSuccess']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.provisionUi.ProvisionerSuccess'?: (params: MessageTypes['keybase.1.provisionUi.ProvisionerSuccess']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.reachability.reachabilityChanged'?: (params: MessageTypes['keybase.1.reachability.reachabilityChanged']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.rekeyUI.delegateRekeyUI'?: (params: MessageTypes['keybase.1.rekeyUI.delegateRekeyUI']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.rekeyUI.refresh'?: (params: MessageTypes['keybase.1.rekeyUI.refresh']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.rekeyUI.rekeySendEvent'?: (params: MessageTypes['keybase.1.rekeyUI.rekeySendEvent']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.saltpackUi.saltpackPromptForDecrypt'?: (params: MessageTypes['keybase.1.saltpackUi.saltpackPromptForDecrypt']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.saltpackUi.saltpackVerifySuccess'?: (params: MessageTypes['keybase.1.saltpackUi.saltpackVerifySuccess']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.saltpackUi.saltpackVerifyBadSender'?: (params: MessageTypes['keybase.1.saltpackUi.saltpackVerifyBadSender']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.secretUi.getPassphrase'?: (params: MessageTypes['keybase.1.secretUi.getPassphrase']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.streamUi.close'?: (params: MessageTypes['keybase.1.streamUi.close']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.streamUi.read'?: (params: MessageTypes['keybase.1.streamUi.read']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.streamUi.reset'?: (params: MessageTypes['keybase.1.streamUi.reset']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.streamUi.write'?: (params: MessageTypes['keybase.1.streamUi.write']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.teamsUi.confirmRootTeamDelete'?: (params: MessageTypes['keybase.1.teamsUi.confirmRootTeamDelete']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.teamsUi.confirmSubteamDelete'?: (params: MessageTypes['keybase.1.teamsUi.confirmSubteamDelete']['inParam'] & {sessionID: number}) => IncomingReturn
  'keybase.1.ui.promptYesNo'?: (params: MessageTypes['keybase.1.ui.promptYesNo']['inParam'] & {sessionID: number}) => IncomingReturn
}

export type CustomResponseIncomingCallMap = {
  'keybase.1.gpgUi.wantToAddGPGKey'?: (params: MessageTypes['keybase.1.gpgUi.wantToAddGPGKey']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.wantToAddGPGKey']['outParam']) => void}) => IncomingReturn
  'keybase.1.gpgUi.confirmDuplicateKeyChosen'?: (params: MessageTypes['keybase.1.gpgUi.confirmDuplicateKeyChosen']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.confirmDuplicateKeyChosen']['outParam']) => void}) => IncomingReturn
  'keybase.1.gpgUi.confirmImportSecretToExistingKey'?: (params: MessageTypes['keybase.1.gpgUi.confirmImportSecretToExistingKey']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.confirmImportSecretToExistingKey']['outParam']) => void}) => IncomingReturn
  'keybase.1.gpgUi.selectKeyAndPushOption'?: (params: MessageTypes['keybase.1.gpgUi.selectKeyAndPushOption']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.selectKeyAndPushOption']['outParam']) => void}) => IncomingReturn
  'keybase.1.gpgUi.selectKey'?: (params: MessageTypes['keybase.1.gpgUi.selectKey']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.selectKey']['outParam']) => void}) => IncomingReturn
  'keybase.1.gpgUi.sign'?: (params: MessageTypes['keybase.1.gpgUi.sign']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.sign']['outParam']) => void}) => IncomingReturn
  'keybase.1.gpgUi.getTTY'?: (params: MessageTypes['keybase.1.gpgUi.getTTY']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gpgUi.getTTY']['outParam']) => void}) => IncomingReturn
  'keybase.1.gregorUI.pushState'?: (params: MessageTypes['keybase.1.gregorUI.pushState']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gregorUI.pushState']['outParam']) => void}) => IncomingReturn
  'keybase.1.gregorUI.pushOutOfBandMessages'?: (params: MessageTypes['keybase.1.gregorUI.pushOutOfBandMessages']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.gregorUI.pushOutOfBandMessages']['outParam']) => void}) => IncomingReturn
  'keybase.1.homeUI.homeUIRefresh'?: (params: MessageTypes['keybase.1.homeUI.homeUIRefresh']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.homeUI.homeUIRefresh']['outParam']) => void}) => IncomingReturn
  'keybase.1.identify3Ui.identify3ShowTracker'?: (params: MessageTypes['keybase.1.identify3Ui.identify3ShowTracker']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identify3Ui.identify3ShowTracker']['outParam']) => void}) => IncomingReturn
  'keybase.1.identify3Ui.identify3UpdateRow'?: (params: MessageTypes['keybase.1.identify3Ui.identify3UpdateRow']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identify3Ui.identify3UpdateRow']['outParam']) => void}) => IncomingReturn
  'keybase.1.identify3Ui.identify3UserReset'?: (params: MessageTypes['keybase.1.identify3Ui.identify3UserReset']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identify3Ui.identify3UserReset']['outParam']) => void}) => IncomingReturn
  'keybase.1.identify3Ui.identify3UpdateUserCard'?: (params: MessageTypes['keybase.1.identify3Ui.identify3UpdateUserCard']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identify3Ui.identify3UpdateUserCard']['outParam']) => void}) => IncomingReturn
  'keybase.1.identify3Ui.identify3TrackerTimedOut'?: (params: MessageTypes['keybase.1.identify3Ui.identify3TrackerTimedOut']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identify3Ui.identify3TrackerTimedOut']['outParam']) => void}) => IncomingReturn
  'keybase.1.identify3Ui.identify3Result'?: (params: MessageTypes['keybase.1.identify3Ui.identify3Result']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identify3Ui.identify3Result']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.displayTLFCreateWithInvite'?: (params: MessageTypes['keybase.1.identifyUi.displayTLFCreateWithInvite']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.displayTLFCreateWithInvite']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.delegateIdentifyUI'?: (params: MessageTypes['keybase.1.identifyUi.delegateIdentifyUI']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.delegateIdentifyUI']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.start'?: (params: MessageTypes['keybase.1.identifyUi.start']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.start']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.displayKey'?: (params: MessageTypes['keybase.1.identifyUi.displayKey']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.displayKey']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.reportLastTrack'?: (params: MessageTypes['keybase.1.identifyUi.reportLastTrack']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.reportLastTrack']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.launchNetworkChecks'?: (params: MessageTypes['keybase.1.identifyUi.launchNetworkChecks']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.launchNetworkChecks']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.displayTrackStatement'?: (params: MessageTypes['keybase.1.identifyUi.displayTrackStatement']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.displayTrackStatement']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.finishWebProofCheck'?: (params: MessageTypes['keybase.1.identifyUi.finishWebProofCheck']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.finishWebProofCheck']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.finishSocialProofCheck'?: (params: MessageTypes['keybase.1.identifyUi.finishSocialProofCheck']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.finishSocialProofCheck']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.displayCryptocurrency'?: (params: MessageTypes['keybase.1.identifyUi.displayCryptocurrency']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.displayCryptocurrency']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.displayStellarAccount'?: (params: MessageTypes['keybase.1.identifyUi.displayStellarAccount']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.displayStellarAccount']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.reportTrackToken'?: (params: MessageTypes['keybase.1.identifyUi.reportTrackToken']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.reportTrackToken']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.displayUserCard'?: (params: MessageTypes['keybase.1.identifyUi.displayUserCard']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.displayUserCard']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.confirm'?: (params: MessageTypes['keybase.1.identifyUi.confirm']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.confirm']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.cancel'?: (params: MessageTypes['keybase.1.identifyUi.cancel']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.cancel']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.finish'?: (params: MessageTypes['keybase.1.identifyUi.finish']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.finish']['outParam']) => void}) => IncomingReturn
  'keybase.1.identifyUi.dismiss'?: (params: MessageTypes['keybase.1.identifyUi.dismiss']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.identifyUi.dismiss']['outParam']) => void}) => IncomingReturn
  'keybase.1.logUi.log'?: (params: MessageTypes['keybase.1.logUi.log']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.logUi.log']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.getEmailOrUsername'?: (params: MessageTypes['keybase.1.loginUi.getEmailOrUsername']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.getEmailOrUsername']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.promptRevokePaperKeys'?: (params: MessageTypes['keybase.1.loginUi.promptRevokePaperKeys']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.promptRevokePaperKeys']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.displayPaperKeyPhrase'?: (params: MessageTypes['keybase.1.loginUi.displayPaperKeyPhrase']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.displayPaperKeyPhrase']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.displayPrimaryPaperKey'?: (params: MessageTypes['keybase.1.loginUi.displayPrimaryPaperKey']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.displayPrimaryPaperKey']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.promptResetAccount'?: (params: MessageTypes['keybase.1.loginUi.promptResetAccount']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.promptResetAccount']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.displayResetProgress'?: (params: MessageTypes['keybase.1.loginUi.displayResetProgress']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.displayResetProgress']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.explainDeviceRecovery'?: (params: MessageTypes['keybase.1.loginUi.explainDeviceRecovery']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.explainDeviceRecovery']['outParam']) => void}) => IncomingReturn
  'keybase.1.loginUi.promptPassphraseRecovery'?: (params: MessageTypes['keybase.1.loginUi.promptPassphraseRecovery']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.loginUi.promptPassphraseRecovery']['outParam']) => void}) => IncomingReturn
  'keybase.1.logsend.prepareLogsend'?: (params: MessageTypes['keybase.1.logsend.prepareLogsend']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.logsend.prepareLogsend']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyApp.exit'?: (params: MessageTypes['keybase.1.NotifyApp.exit']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyApp.exit']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyEmailAddress.emailAddressVerified'?: (params: MessageTypes['keybase.1.NotifyEmailAddress.emailAddressVerified']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyEmailAddress.emailAddressVerified']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyFS.FSSyncActivity'?: (params: MessageTypes['keybase.1.NotifyFS.FSSyncActivity']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyFS.FSSyncActivity']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyFS.FSEditListResponse'?: (params: MessageTypes['keybase.1.NotifyFS.FSEditListResponse']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyFS.FSEditListResponse']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyFS.FSSyncStatusResponse'?: (params: MessageTypes['keybase.1.NotifyFS.FSSyncStatusResponse']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyFS.FSSyncStatusResponse']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyFS.FSOverallSyncStatusChanged'?: (params: MessageTypes['keybase.1.NotifyFS.FSOverallSyncStatusChanged']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyFS.FSOverallSyncStatusChanged']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyFS.FSFavoritesChanged'?: (params: MessageTypes['keybase.1.NotifyFS.FSFavoritesChanged']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyFS.FSFavoritesChanged']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyFS.FSOnlineStatusChanged'?: (params: MessageTypes['keybase.1.NotifyFS.FSOnlineStatusChanged']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyFS.FSOnlineStatusChanged']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyKeyfamily.keyfamilyChanged'?: (params: MessageTypes['keybase.1.NotifyKeyfamily.keyfamilyChanged']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyKeyfamily.keyfamilyChanged']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyPaperKey.paperKeyCached'?: (params: MessageTypes['keybase.1.NotifyPaperKey.paperKeyCached']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyPaperKey.paperKeyCached']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyPGP.pgpKeyInSecretStoreFile'?: (params: MessageTypes['keybase.1.NotifyPGP.pgpKeyInSecretStoreFile']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyPGP.pgpKeyInSecretStoreFile']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyPhoneNumber.phoneNumberAdded'?: (params: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberAdded']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberAdded']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyPhoneNumber.phoneNumberVerified'?: (params: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberVerified']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberVerified']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyPhoneNumber.phoneNumberSuperseded'?: (params: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberSuperseded']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyPhoneNumber.phoneNumberSuperseded']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyService.shutdown'?: (params: MessageTypes['keybase.1.NotifyService.shutdown']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyService.shutdown']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifySession.loggedIn'?: (params: MessageTypes['keybase.1.NotifySession.loggedIn']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifySession.loggedIn']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifySession.clientOutOfDate'?: (params: MessageTypes['keybase.1.NotifySession.clientOutOfDate']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifySession.clientOutOfDate']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.teamChangedByID'?: (params: MessageTypes['keybase.1.NotifyTeam.teamChangedByID']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.teamChangedByID']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.teamChangedByName'?: (params: MessageTypes['keybase.1.NotifyTeam.teamChangedByName']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.teamChangedByName']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.teamDeleted'?: (params: MessageTypes['keybase.1.NotifyTeam.teamDeleted']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.teamDeleted']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.teamAbandoned'?: (params: MessageTypes['keybase.1.NotifyTeam.teamAbandoned']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.teamAbandoned']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.teamExit'?: (params: MessageTypes['keybase.1.NotifyTeam.teamExit']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.teamExit']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.newlyAddedToTeam'?: (params: MessageTypes['keybase.1.NotifyTeam.newlyAddedToTeam']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.newlyAddedToTeam']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyTeam.avatarUpdated'?: (params: MessageTypes['keybase.1.NotifyTeam.avatarUpdated']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyTeam.avatarUpdated']['outParam']) => void}) => IncomingReturn
  'keybase.1.NotifyUsers.passwordChanged'?: (params: MessageTypes['keybase.1.NotifyUsers.passwordChanged']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.NotifyUsers.passwordChanged']['outParam']) => void}) => IncomingReturn
  'keybase.1.pgpUi.outputSignatureSuccess'?: (params: MessageTypes['keybase.1.pgpUi.outputSignatureSuccess']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.pgpUi.outputSignatureSuccess']['outParam']) => void}) => IncomingReturn
  'keybase.1.pgpUi.outputSignatureSuccessNonKeybase'?: (params: MessageTypes['keybase.1.pgpUi.outputSignatureSuccessNonKeybase']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.pgpUi.outputSignatureSuccessNonKeybase']['outParam']) => void}) => IncomingReturn
  'keybase.1.pgpUi.keyGenerated'?: (params: MessageTypes['keybase.1.pgpUi.keyGenerated']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.pgpUi.keyGenerated']['outParam']) => void}) => IncomingReturn
  'keybase.1.pgpUi.shouldPushPrivate'?: (params: MessageTypes['keybase.1.pgpUi.shouldPushPrivate']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.pgpUi.shouldPushPrivate']['outParam']) => void}) => IncomingReturn
  'keybase.1.pgpUi.finished'?: (params: MessageTypes['keybase.1.pgpUi.finished']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.pgpUi.finished']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.promptOverwrite'?: (params: MessageTypes['keybase.1.proveUi.promptOverwrite']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.promptOverwrite']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.promptUsername'?: (params: MessageTypes['keybase.1.proveUi.promptUsername']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.promptUsername']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.outputPrechecks'?: (params: MessageTypes['keybase.1.proveUi.outputPrechecks']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.outputPrechecks']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.preProofWarning'?: (params: MessageTypes['keybase.1.proveUi.preProofWarning']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.preProofWarning']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.outputInstructions'?: (params: MessageTypes['keybase.1.proveUi.outputInstructions']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.outputInstructions']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.okToCheck'?: (params: MessageTypes['keybase.1.proveUi.okToCheck']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.okToCheck']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.checking'?: (params: MessageTypes['keybase.1.proveUi.checking']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.checking']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.continueChecking'?: (params: MessageTypes['keybase.1.proveUi.continueChecking']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.continueChecking']['outParam']) => void}) => IncomingReturn
  'keybase.1.proveUi.displayRecheckWarning'?: (params: MessageTypes['keybase.1.proveUi.displayRecheckWarning']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.proveUi.displayRecheckWarning']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.chooseProvisioningMethod'?: (params: MessageTypes['keybase.1.provisionUi.chooseProvisioningMethod']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.chooseProvisioningMethod']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.chooseGPGMethod'?: (params: MessageTypes['keybase.1.provisionUi.chooseGPGMethod']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.chooseGPGMethod']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.switchToGPGSignOK'?: (params: MessageTypes['keybase.1.provisionUi.switchToGPGSignOK']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.switchToGPGSignOK']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.chooseDevice'?: (params: MessageTypes['keybase.1.provisionUi.chooseDevice']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.chooseDevice']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.chooseDeviceType'?: (params: MessageTypes['keybase.1.provisionUi.chooseDeviceType']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.chooseDeviceType']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.DisplayAndPromptSecret'?: (params: MessageTypes['keybase.1.provisionUi.DisplayAndPromptSecret']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.DisplayAndPromptSecret']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.DisplaySecretExchanged'?: (params: MessageTypes['keybase.1.provisionUi.DisplaySecretExchanged']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.DisplaySecretExchanged']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.PromptNewDeviceName'?: (params: MessageTypes['keybase.1.provisionUi.PromptNewDeviceName']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.PromptNewDeviceName']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.ProvisioneeSuccess'?: (params: MessageTypes['keybase.1.provisionUi.ProvisioneeSuccess']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.ProvisioneeSuccess']['outParam']) => void}) => IncomingReturn
  'keybase.1.provisionUi.ProvisionerSuccess'?: (params: MessageTypes['keybase.1.provisionUi.ProvisionerSuccess']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.provisionUi.ProvisionerSuccess']['outParam']) => void}) => IncomingReturn
  'keybase.1.rekeyUI.delegateRekeyUI'?: (params: MessageTypes['keybase.1.rekeyUI.delegateRekeyUI']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.rekeyUI.delegateRekeyUI']['outParam']) => void}) => IncomingReturn
  'keybase.1.rekeyUI.refresh'?: (params: MessageTypes['keybase.1.rekeyUI.refresh']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.rekeyUI.refresh']['outParam']) => void}) => IncomingReturn
  'keybase.1.rekeyUI.rekeySendEvent'?: (params: MessageTypes['keybase.1.rekeyUI.rekeySendEvent']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.rekeyUI.rekeySendEvent']['outParam']) => void}) => IncomingReturn
  'keybase.1.saltpackUi.saltpackPromptForDecrypt'?: (params: MessageTypes['keybase.1.saltpackUi.saltpackPromptForDecrypt']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.saltpackUi.saltpackPromptForDecrypt']['outParam']) => void}) => IncomingReturn
  'keybase.1.saltpackUi.saltpackVerifySuccess'?: (params: MessageTypes['keybase.1.saltpackUi.saltpackVerifySuccess']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.saltpackUi.saltpackVerifySuccess']['outParam']) => void}) => IncomingReturn
  'keybase.1.saltpackUi.saltpackVerifyBadSender'?: (params: MessageTypes['keybase.1.saltpackUi.saltpackVerifyBadSender']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.saltpackUi.saltpackVerifyBadSender']['outParam']) => void}) => IncomingReturn
  'keybase.1.secretUi.getPassphrase'?: (params: MessageTypes['keybase.1.secretUi.getPassphrase']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.secretUi.getPassphrase']['outParam']) => void}) => IncomingReturn
  'keybase.1.streamUi.close'?: (params: MessageTypes['keybase.1.streamUi.close']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.streamUi.close']['outParam']) => void}) => IncomingReturn
  'keybase.1.streamUi.read'?: (params: MessageTypes['keybase.1.streamUi.read']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.streamUi.read']['outParam']) => void}) => IncomingReturn
  'keybase.1.streamUi.reset'?: (params: MessageTypes['keybase.1.streamUi.reset']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.streamUi.reset']['outParam']) => void}) => IncomingReturn
  'keybase.1.streamUi.write'?: (params: MessageTypes['keybase.1.streamUi.write']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.streamUi.write']['outParam']) => void}) => IncomingReturn
  'keybase.1.teamsUi.confirmRootTeamDelete'?: (params: MessageTypes['keybase.1.teamsUi.confirmRootTeamDelete']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.teamsUi.confirmRootTeamDelete']['outParam']) => void}) => IncomingReturn
  'keybase.1.teamsUi.confirmSubteamDelete'?: (params: MessageTypes['keybase.1.teamsUi.confirmSubteamDelete']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.teamsUi.confirmSubteamDelete']['outParam']) => void}) => IncomingReturn
  'keybase.1.ui.promptYesNo'?: (params: MessageTypes['keybase.1.ui.promptYesNo']['inParam'] & {sessionID: number}, response: {error: IncomingErrorCallback; result: (res: MessageTypes['keybase.1.ui.promptYesNo']['outParam']) => void}) => IncomingReturn
}
export const SimpleFSSimpleFSAreWeConnectedToMDServerRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSAreWeConnectedToMDServer']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSAreWeConnectedToMDServer']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSAreWeConnectedToMDServer', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSCancelRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSCancel']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSCancel']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCancel', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSCheckReachabilityRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSCheckReachability']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSCheckReachability']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCheckReachability', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSCheckRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSCheck']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSCheck']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCheck', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSClearConflictStateRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSClearConflictState']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSClearConflictState']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSClearConflictState', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSCopyRecursiveRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSCopyRecursive']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSCopyRecursive']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSCopyRecursive', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSFinishResolvingConflictRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSFinishResolvingConflict']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSFinishResolvingConflict']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSFinishResolvingConflict', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSFolderSyncConfigAndStatusRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSFolderSyncConfigAndStatus']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSFolderSyncConfigAndStatus']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSFolderSyncConfigAndStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSGetHTTPAddressAndTokenRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.SimpleFSGetHTTPAddressAndToken']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.SimpleFSGetHTTPAddressAndToken']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.SimpleFSGetHTTPAddressAndToken', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSListFavoritesRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSListFavorites']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSListFavorites']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSListFavorites', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSListRecursiveToDepthRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSListRecursiveToDepth']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSListRecursiveToDepth']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSListRecursiveToDepth', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSListRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSList']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSList']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSList', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSMoveRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSMove']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSMove']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSMove', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSOpenRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSOpen']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSOpen']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSOpen', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSReadListRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSReadList']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSReadList']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSReadList', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSRemoveRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSRemove']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSRemove']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSRemove', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSSetFolderSyncConfigRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSSetFolderSyncConfig']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSSetFolderSyncConfig']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSSetFolderSyncConfig', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSSetNotificationThresholdRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSSetNotificationThreshold']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSSetNotificationThreshold']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSSetNotificationThreshold', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSSettingsRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSSettings']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSSettings']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSSettings', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSStatRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSStat']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSStat']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSStat', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSSyncConfigAndStatusRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSSyncConfigAndStatus']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSSyncConfigAndStatus']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSSyncConfigAndStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSSyncStatusRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSSyncStatus']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSSyncStatus']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSSyncStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSUserEditHistoryRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSUserEditHistory']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSUserEditHistory']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSUserEditHistory', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const SimpleFSSimpleFSWaitRpcPromise = (params: MessageTypes['keybase.1.SimpleFS.simpleFSWait']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.SimpleFS.simpleFSWait']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.SimpleFS.simpleFSWait', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountEmailChangeRpcPromise = (params: MessageTypes['keybase.1.account.emailChange']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.emailChange']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.emailChange', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountGetLockdownModeRpcPromise = (params: MessageTypes['keybase.1.account.getLockdownMode']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.getLockdownMode']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.getLockdownMode', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountHasServerKeysRpcPromise = (params: MessageTypes['keybase.1.account.hasServerKeys']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.hasServerKeys']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.hasServerKeys', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountPassphraseChangeRpcPromise = (params: MessageTypes['keybase.1.account.passphraseChange']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.passphraseChange']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.passphraseChange', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountPassphraseCheckRpcPromise = (params: MessageTypes['keybase.1.account.passphraseCheck']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.passphraseCheck']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.passphraseCheck', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountRecoverUsernameWithEmailRpcPromise = (params: MessageTypes['keybase.1.account.recoverUsernameWithEmail']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.recoverUsernameWithEmail']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.recoverUsernameWithEmail', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const accountSetLockdownModeRpcPromise = (params: MessageTypes['keybase.1.account.setLockdownMode']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.account.setLockdownMode']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.account.setLockdownMode', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverDeleteRpcPromise = (params: MessageTypes['keybase.1.apiserver.Delete']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.apiserver.Delete']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.Delete', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverGetRpcPromise = (params: MessageTypes['keybase.1.apiserver.Get']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.apiserver.Get']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.Get', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverGetWithSessionRpcPromise = (params: MessageTypes['keybase.1.apiserver.GetWithSession']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.apiserver.GetWithSession']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.GetWithSession', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverPostJSONRpcPromise = (params: MessageTypes['keybase.1.apiserver.PostJSON']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.apiserver.PostJSON']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.PostJSON', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const apiserverPostRpcPromise = (params: MessageTypes['keybase.1.apiserver.Post']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.apiserver.Post']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.apiserver.Post', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const appStatePowerMonitorEventRpcPromise = (params: MessageTypes['keybase.1.appState.powerMonitorEvent']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.appState.powerMonitorEvent']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.appState.powerMonitorEvent', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const avatarsLoadTeamAvatarsRpcPromise = (params: MessageTypes['keybase.1.avatars.loadTeamAvatars']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.avatars.loadTeamAvatars']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.avatars.loadTeamAvatars', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const avatarsLoadUserAvatarsRpcPromise = (params: MessageTypes['keybase.1.avatars.loadUserAvatars']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.avatars.loadUserAvatars']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.avatars.loadUserAvatars', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetAllProvisionedUsernamesRpcPromise = (params: MessageTypes['keybase.1.config.getAllProvisionedUsernames']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getAllProvisionedUsernames']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getAllProvisionedUsernames', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetBootstrapStatusRpcPromise = (params: MessageTypes['keybase.1.config.getBootstrapStatus']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getBootstrapStatus']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getBootstrapStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetConfigRpcPromise = (params: MessageTypes['keybase.1.config.getConfig']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getConfig']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getConfig', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetRememberPassphraseRpcPromise = (params: MessageTypes['keybase.1.config.getRememberPassphrase']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getRememberPassphrase']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getRememberPassphrase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetUpdateInfo2RpcPromise = (params: MessageTypes['keybase.1.config.getUpdateInfo2']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getUpdateInfo2']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getUpdateInfo2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetUpdateInfoRpcPromise = (params: MessageTypes['keybase.1.config.getUpdateInfo']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getUpdateInfo']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getUpdateInfo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configGetValueRpcPromise = (params: MessageTypes['keybase.1.config.getValue']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.getValue']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.getValue', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configHelloIAmRpcPromise = (params: MessageTypes['keybase.1.config.helloIAm']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.helloIAm']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.helloIAm', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configLogSendRpcPromise = (params: MessageTypes['keybase.1.config.logSend']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.logSend']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.logSend', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configSetRememberPassphraseRpcPromise = (params: MessageTypes['keybase.1.config.setRememberPassphrase']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.setRememberPassphrase']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.setRememberPassphrase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configSetValueRpcPromise = (params: MessageTypes['keybase.1.config.setValue']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.setValue']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.setValue', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configStartUpdateIfNeededRpcPromise = (params: MessageTypes['keybase.1.config.startUpdateIfNeeded']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.startUpdateIfNeeded']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.startUpdateIfNeeded', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const configWaitForClientRpcPromise = (params: MessageTypes['keybase.1.config.waitForClient']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.config.waitForClient']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.config.waitForClient', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const cryptocurrencyRegisterAddressRpcPromise = (params: MessageTypes['keybase.1.cryptocurrency.registerAddress']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.cryptocurrency.registerAddress']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.cryptocurrency.registerAddress', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const ctlDbCleanRpcPromise = (params: MessageTypes['keybase.1.ctl.dbClean']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.ctl.dbClean']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.ctl.dbClean', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const ctlDbNukeRpcPromise = (params: MessageTypes['keybase.1.ctl.dbNuke']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.ctl.dbNuke']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.ctl.dbNuke', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const ctlStopRpcPromise = (params: MessageTypes['keybase.1.ctl.stop']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.ctl.stop']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.ctl.stop', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterChatUIRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerChatUI']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerChatUI']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerChatUI', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterGregorFirehoseFilteredRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerGregorFirehoseFiltered']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerGregorFirehoseFiltered']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerGregorFirehoseFiltered', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterHomeUIRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerHomeUI']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerHomeUI']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerHomeUI', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterIdentify3UIRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerIdentify3UI']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerIdentify3UI']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerIdentify3UI', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterIdentifyUIRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerIdentifyUI']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerIdentifyUI']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerIdentifyUI', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterRekeyUIRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerRekeyUI']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerRekeyUI']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerRekeyUI', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const delegateUiCtlRegisterSecretUIRpcPromise = (params: MessageTypes['keybase.1.delegateUiCtl.registerSecretUI']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.delegateUiCtl.registerSecretUI']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.delegateUiCtl.registerSecretUI', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const deviceCheckDeviceNameFormatRpcPromise = (params: MessageTypes['keybase.1.device.checkDeviceNameFormat']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.device.checkDeviceNameFormat']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.device.checkDeviceNameFormat', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const deviceDeviceAddRpcSaga = (p: {params: MessageTypes['keybase.1.device.deviceAdd']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.device.deviceAdd', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const deviceDeviceHistoryListRpcPromise = (params: MessageTypes['keybase.1.device.deviceHistoryList']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.device.deviceHistoryList']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.device.deviceHistoryList', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const deviceDismissDeviceChangeNotificationsRpcPromise = (params: MessageTypes['keybase.1.device.dismissDeviceChangeNotifications']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.device.dismissDeviceChangeNotifications']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.device.dismissDeviceChangeNotifications', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const favoriteFavoriteAddRpcPromise = (params: MessageTypes['keybase.1.favorite.favoriteAdd']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.favorite.favoriteAdd']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.favorite.favoriteAdd', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const favoriteFavoriteIgnoreRpcPromise = (params: MessageTypes['keybase.1.favorite.favoriteIgnore']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.favorite.favoriteIgnore']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.favorite.favoriteIgnore', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitCreatePersonalRepoRpcPromise = (params: MessageTypes['keybase.1.git.createPersonalRepo']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.createPersonalRepo']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.createPersonalRepo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitCreateTeamRepoRpcPromise = (params: MessageTypes['keybase.1.git.createTeamRepo']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.createTeamRepo']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.createTeamRepo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitDeletePersonalRepoRpcPromise = (params: MessageTypes['keybase.1.git.deletePersonalRepo']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.deletePersonalRepo']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.deletePersonalRepo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitDeleteTeamRepoRpcPromise = (params: MessageTypes['keybase.1.git.deleteTeamRepo']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.deleteTeamRepo']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.deleteTeamRepo', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitGetAllGitMetadataRpcPromise = (params: MessageTypes['keybase.1.git.getAllGitMetadata']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.getAllGitMetadata']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.getAllGitMetadata', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitGetGitMetadataRpcPromise = (params: MessageTypes['keybase.1.git.getGitMetadata']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.getGitMetadata']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.getGitMetadata', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gitSetTeamRepoSettingsRpcPromise = (params: MessageTypes['keybase.1.git.setTeamRepoSettings']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.git.setTeamRepoSettings']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.git.setTeamRepoSettings', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorDismissCategoryRpcPromise = (params: MessageTypes['keybase.1.gregor.dismissCategory']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.gregor.dismissCategory']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.dismissCategory', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorDismissItemRpcPromise = (params: MessageTypes['keybase.1.gregor.dismissItem']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.gregor.dismissItem']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.dismissItem', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorGetStateRpcPromise = (params: MessageTypes['keybase.1.gregor.getState']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.gregor.getState']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.getState', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorInjectItemRpcPromise = (params: MessageTypes['keybase.1.gregor.injectItem']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.gregor.injectItem']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.injectItem', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorUpdateCategoryRpcPromise = (params: MessageTypes['keybase.1.gregor.updateCategory']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.gregor.updateCategory']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.updateCategory', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const gregorUpdateItemRpcPromise = (params: MessageTypes['keybase.1.gregor.updateItem']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.gregor.updateItem']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.gregor.updateItem', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const homeHomeDismissAnnouncementRpcPromise = (params: MessageTypes['keybase.1.home.homeDismissAnnouncement']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.home.homeDismissAnnouncement']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeDismissAnnouncement', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const homeHomeGetScreenRpcPromise = (params: MessageTypes['keybase.1.home.homeGetScreen']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.home.homeGetScreen']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeGetScreen', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const homeHomeMarkViewedRpcPromise = (params: MessageTypes['keybase.1.home.homeMarkViewed']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.home.homeMarkViewed']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeMarkViewed', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const homeHomeSkipTodoTypeRpcPromise = (params: MessageTypes['keybase.1.home.homeSkipTodoType']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.home.homeSkipTodoType']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.home.homeSkipTodoType', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const identify3Identify3FollowUserRpcPromise = (params: MessageTypes['keybase.1.identify3.identify3FollowUser']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.identify3.identify3FollowUser']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.identify3.identify3FollowUser', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const identify3Identify3IgnoreUserRpcPromise = (params: MessageTypes['keybase.1.identify3.identify3IgnoreUser']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.identify3.identify3IgnoreUser']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.identify3.identify3IgnoreUser', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const identify3Identify3RpcSaga = (p: {params: MessageTypes['keybase.1.identify3.identify3']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.identify3.identify3', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const identifyIdentify2RpcPromise = (params: MessageTypes['keybase.1.identify.identify2']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.identify.identify2']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.identify.identify2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installFuseStatusRpcPromise = (params: MessageTypes['keybase.1.install.fuseStatus']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.install.fuseStatus']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.fuseStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installInstallFuseRpcPromise = (params: MessageTypes['keybase.1.install.installFuse']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.install.installFuse']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.installFuse', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installInstallKBFSRpcPromise = (params: MessageTypes['keybase.1.install.installKBFS']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.install.installKBFS']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.installKBFS', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const installUninstallKBFSRpcPromise = (params: MessageTypes['keybase.1.install.uninstallKBFS']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.install.uninstallKBFS']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.install.uninstallKBFS', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const kbfsMountGetCurrentMountDirRpcPromise = (params: MessageTypes['keybase.1.kbfsMount.GetCurrentMountDir']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.kbfsMount.GetCurrentMountDir']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.kbfsMount.GetCurrentMountDir', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginAccountDeleteRpcPromise = (params: MessageTypes['keybase.1.login.accountDelete']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.login.accountDelete']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.accountDelete', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginDeprovisionRpcPromise = (params: MessageTypes['keybase.1.login.deprovision']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.login.deprovision']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.deprovision', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginGetConfiguredAccountsRpcPromise = (params: MessageTypes['keybase.1.login.getConfiguredAccounts']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.login.getConfiguredAccounts']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.getConfiguredAccounts', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginLoginRpcSaga = (p: {params: MessageTypes['keybase.1.login.login']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.login.login', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const loginLogoutRpcPromise = (params: MessageTypes['keybase.1.login.logout']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.login.logout']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.logout', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const loginPaperKeyRpcSaga = (p: {params: MessageTypes['keybase.1.login.paperKey']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.login.paperKey', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const loginPaperKeySubmitRpcPromise = (params: MessageTypes['keybase.1.login.paperKeySubmit']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.login.paperKeySubmit']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.login.paperKeySubmit', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const notifyCtlSetNotificationsRpcPromise = (params: MessageTypes['keybase.1.notifyCtl.setNotifications']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.notifyCtl.setNotifications']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.notifyCtl.setNotifications', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const pgpPgpKeyGenDefaultRpcSaga = (p: {params: MessageTypes['keybase.1.pgp.pgpKeyGenDefault']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.pgp.pgpKeyGenDefault', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const pgpPgpStorageDismissRpcPromise = (params: MessageTypes['keybase.1.pgp.pgpStorageDismiss']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.pgp.pgpStorageDismiss']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.pgp.pgpStorageDismiss', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const pprofLogProcessorProfileRpcPromise = (params: MessageTypes['keybase.1.pprof.logProcessorProfile']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.pprof.logProcessorProfile']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.pprof.logProcessorProfile', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const pprofLogTraceRpcPromise = (params: MessageTypes['keybase.1.pprof.logTrace']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.pprof.logTrace']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.pprof.logTrace', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const proveCheckProofRpcPromise = (params: MessageTypes['keybase.1.prove.checkProof']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.prove.checkProof']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.prove.checkProof', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const proveStartProofRpcSaga = (p: {params: MessageTypes['keybase.1.prove.startProof']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.prove.startProof', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const reachabilityCheckReachabilityRpcPromise = (params: MessageTypes['keybase.1.reachability.checkReachability']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.reachability.checkReachability']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.reachability.checkReachability', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const reachabilityStartReachabilityRpcPromise = (params: MessageTypes['keybase.1.reachability.startReachability']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.reachability.startReachability']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.reachability.startReachability', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const rekeyGetRevokeWarningRpcPromise = (params: MessageTypes['keybase.1.rekey.getRevokeWarning']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.rekey.getRevokeWarning']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.rekey.getRevokeWarning', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const rekeyRekeyStatusFinishRpcPromise = (params: MessageTypes['keybase.1.rekey.rekeyStatusFinish']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.rekey.rekeyStatusFinish']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.rekey.rekeyStatusFinish', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const rekeyShowPendingRekeyStatusRpcPromise = (params: MessageTypes['keybase.1.rekey.showPendingRekeyStatus']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.rekey.showPendingRekeyStatus']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.rekey.showPendingRekeyStatus', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const revokeRevokeDeviceRpcPromise = (params: MessageTypes['keybase.1.revoke.revokeDevice']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.revoke.revokeDevice']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.revoke.revokeDevice', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const revokeRevokeKeyRpcPromise = (params: MessageTypes['keybase.1.revoke.revokeKey']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.revoke.revokeKey']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.revoke.revokeKey', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const revokeRevokeSigsRpcPromise = (params: MessageTypes['keybase.1.revoke.revokeSigs']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.revoke.revokeSigs']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.revoke.revokeSigs', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const signupCheckInvitationCodeRpcPromise = (params: MessageTypes['keybase.1.signup.checkInvitationCode']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.signup.checkInvitationCode']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.checkInvitationCode', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const signupCheckUsernameAvailableRpcPromise = (params: MessageTypes['keybase.1.signup.checkUsernameAvailable']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.signup.checkUsernameAvailable']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.checkUsernameAvailable', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const signupGetInvitationCodeRpcPromise = (params: MessageTypes['keybase.1.signup.getInvitationCode']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.signup.getInvitationCode']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.getInvitationCode', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const signupInviteRequestRpcPromise = (params: MessageTypes['keybase.1.signup.inviteRequest']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.signup.inviteRequest']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.signup.inviteRequest', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const signupSignupRpcSaga = (p: {params: MessageTypes['keybase.1.signup.signup']['inParam']; incomingCallMap: IncomingCallMapType; customResponseIncomingCallMap?: CustomResponseIncomingCallMap; waitingKey?: WaitingKey}) => call(getEngineSaga(), {method: 'keybase.1.signup.signup', params: p.params, incomingCallMap: p.incomingCallMap, customResponseIncomingCallMap: p.customResponseIncomingCallMap, waitingKey: p.waitingKey})
export const teamsCanUserPerformRpcPromise = (params: MessageTypes['keybase.1.teams.canUserPerform']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.canUserPerform']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.canUserPerform', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsGetTarsDisabledRpcPromise = (params: MessageTypes['keybase.1.teams.getTarsDisabled']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.getTarsDisabled']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.getTarsDisabled', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsGetTeamAndMemberShowcaseRpcPromise = (params: MessageTypes['keybase.1.teams.getTeamAndMemberShowcase']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.getTeamAndMemberShowcase']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.getTeamAndMemberShowcase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsSetTarsDisabledRpcPromise = (params: MessageTypes['keybase.1.teams.setTarsDisabled']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.setTarsDisabled']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.setTarsDisabled', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsSetTeamMemberShowcaseRpcPromise = (params: MessageTypes['keybase.1.teams.setTeamMemberShowcase']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.setTeamMemberShowcase']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.setTeamMemberShowcase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsSetTeamShowcaseRpcPromise = (params: MessageTypes['keybase.1.teams.setTeamShowcase']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.setTeamShowcase']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.setTeamShowcase', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAcceptInviteOrRequestAccessRpcPromise = (params: MessageTypes['keybase.1.teams.teamAcceptInviteOrRequestAccess']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamAcceptInviteOrRequestAccess']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAcceptInviteOrRequestAccess', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAddEmailsBulkRpcPromise = (params: MessageTypes['keybase.1.teams.teamAddEmailsBulk']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamAddEmailsBulk']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAddEmailsBulk', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAddMemberRpcPromise = (params: MessageTypes['keybase.1.teams.teamAddMember']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamAddMember']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAddMember', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamAddMembersRpcPromise = (params: MessageTypes['keybase.1.teams.teamAddMembers']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamAddMembers']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamAddMembers', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamCreateRpcPromise = (params: MessageTypes['keybase.1.teams.teamCreate']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamCreate']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamCreate', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamCreateSeitanTokenV2RpcPromise = (params: MessageTypes['keybase.1.teams.teamCreateSeitanTokenV2']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamCreateSeitanTokenV2']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamCreateSeitanTokenV2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamEditMemberRpcPromise = (params: MessageTypes['keybase.1.teams.teamEditMember']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamEditMember']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamEditMember', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamGetMembersRpcPromise = (params: MessageTypes['keybase.1.teams.teamGetMembers']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamGetMembers']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamGetMembers', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamGetRpcPromise = (params: MessageTypes['keybase.1.teams.teamGet']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamGet']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamGet', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamGetSubteamsRpcPromise = (params: MessageTypes['keybase.1.teams.teamGetSubteams']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamGetSubteams']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamGetSubteams', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamIgnoreRequestRpcPromise = (params: MessageTypes['keybase.1.teams.teamIgnoreRequest']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamIgnoreRequest']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamIgnoreRequest', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamLeaveRpcPromise = (params: MessageTypes['keybase.1.teams.teamLeave']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamLeave']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamLeave', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamListMyAccessRequestsRpcPromise = (params: MessageTypes['keybase.1.teams.teamListMyAccessRequests']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamListMyAccessRequests']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamListMyAccessRequests', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamListRequestsRpcPromise = (params: MessageTypes['keybase.1.teams.teamListRequests']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamListRequests']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamListRequests', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamListUnverifiedRpcPromise = (params: MessageTypes['keybase.1.teams.teamListUnverified']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamListUnverified']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamListUnverified', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamProfileAddListRpcPromise = (params: MessageTypes['keybase.1.teams.teamProfileAddList']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamProfileAddList']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamProfileAddList', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamReAddMemberAfterResetRpcPromise = (params: MessageTypes['keybase.1.teams.teamReAddMemberAfterReset']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamReAddMemberAfterReset']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamReAddMemberAfterReset', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamRemoveMemberRpcPromise = (params: MessageTypes['keybase.1.teams.teamRemoveMember']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamRemoveMember']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamRemoveMember', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamRenameRpcPromise = (params: MessageTypes['keybase.1.teams.teamRename']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamRename']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamRename', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsTeamSetSettingsRpcPromise = (params: MessageTypes['keybase.1.teams.teamSetSettings']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.teamSetSettings']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.teamSetSettings', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const teamsUploadTeamAvatarRpcPromise = (params: MessageTypes['keybase.1.teams.uploadTeamAvatar']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.teams.uploadTeamAvatar']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.teams.uploadTeamAvatar', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const trackCheckTrackingRpcPromise = (params: MessageTypes['keybase.1.track.checkTracking']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.track.checkTracking']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.checkTracking', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const trackDismissWithTokenRpcPromise = (params: MessageTypes['keybase.1.track.dismissWithToken']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.track.dismissWithToken']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.dismissWithToken', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const trackTrackWithTokenRpcPromise = (params: MessageTypes['keybase.1.track.trackWithToken']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.track.trackWithToken']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.trackWithToken', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const trackUntrackRpcPromise = (params: MessageTypes['keybase.1.track.untrack']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.track.untrack']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.track.untrack', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userCanLogoutRpcPromise = (params: MessageTypes['keybase.1.user.canLogout']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.canLogout']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.canLogout', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userInterestingPeopleRpcPromise = (params: MessageTypes['keybase.1.user.interestingPeople']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.interestingPeople']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.interestingPeople', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userListTrackers2RpcPromise = (params: MessageTypes['keybase.1.user.listTrackers2']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.listTrackers2']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.listTrackers2', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userLoadHasRandomPwRpcPromise = (params: MessageTypes['keybase.1.user.loadHasRandomPw']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.loadHasRandomPw']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.loadHasRandomPw', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userLoadMySettingsRpcPromise = (params: MessageTypes['keybase.1.user.loadMySettings']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.loadMySettings']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.loadMySettings', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userProfileEditRpcPromise = (params: MessageTypes['keybase.1.user.profileEdit']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.profileEdit']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.profileEdit', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userProofSuggestionsRpcPromise = (params: MessageTypes['keybase.1.user.proofSuggestions']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.proofSuggestions']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.proofSuggestions', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
export const userUploadUserAvatarRpcPromise = (params: MessageTypes['keybase.1.user.uploadUserAvatar']['inParam'], waitingKey?: WaitingKey) => new Promise<MessageTypes['keybase.1.user.uploadUserAvatar']['outParam']>((resolve, reject) => engine()._rpcOutgoing({method: 'keybase.1.user.uploadUserAvatar', params, callback: (error, result) => (error ? reject(error) : resolve(result)), waitingKey}))
// Not enabled calls. To enable add to enabled-calls.json:
// 'keybase.1.account.passphrasePrompt'
// 'keybase.1.account.resetAccount'
// 'keybase.1.account.recoverUsernameWithPhone'
// 'keybase.1.account.enterResetPipeline'
// 'keybase.1.account.cancelReset'
// 'keybase.1.account.timeTravelReset'
// 'keybase.1.audit.isInJail'
// 'keybase.1.audit.boxAuditTeam'
// 'keybase.1.audit.attemptBoxAudit'
// 'keybase.1.audit.knownTeamIDs'
// 'keybase.1.badger.getBadgeState'
// 'keybase.1.block.getSessionChallenge'
// 'keybase.1.block.authenticateSession'
// 'keybase.1.block.putBlock'
// 'keybase.1.block.putBlockAgain'
// 'keybase.1.block.getBlock'
// 'keybase.1.block.addReference'
// 'keybase.1.block.delReference'
// 'keybase.1.block.archiveReference'
// 'keybase.1.block.delReferenceWithCount'
// 'keybase.1.block.archiveReferenceWithCount'
// 'keybase.1.block.getReferenceCount'
// 'keybase.1.block.getUserQuotaInfo'
// 'keybase.1.block.getTeamQuotaInfo'
// 'keybase.1.block.blockPing'
// 'keybase.1.BTC.registerBTC'
// 'keybase.1.config.getCurrentStatus'
// 'keybase.1.config.getClientStatus'
// 'keybase.1.config.getFullStatus'
// 'keybase.1.config.setUserConfig'
// 'keybase.1.config.setPath'
// 'keybase.1.config.clearValue'
// 'keybase.1.config.checkAPIServerOutOfDateWarning'
// 'keybase.1.contacts.lookupContactList'
// 'keybase.1.crypto.signED25519'
// 'keybase.1.crypto.signED25519ForKBFS'
// 'keybase.1.crypto.signToString'
// 'keybase.1.crypto.unboxBytes32'
// 'keybase.1.crypto.unboxBytes32Any'
// 'keybase.1.ctl.stopService'
// 'keybase.1.ctl.logRotate'
// 'keybase.1.ctl.reload'
// 'keybase.1.ctl.appExit'
// 'keybase.1.ctl.dbDelete'
// 'keybase.1.ctl.dbPut'
// 'keybase.1.ctl.dbGet'
// 'keybase.1.debugging.firstStep'
// 'keybase.1.debugging.secondStep'
// 'keybase.1.debugging.increment'
// 'keybase.1.debugging.script'
// 'keybase.1.delegateUiCtl.registerUpdateUI'
// 'keybase.1.delegateUiCtl.registerGregorFirehose'
// 'keybase.1.device.deviceList'
// 'keybase.1.device.checkDeviceNameForUser'
// 'keybase.1.emails.addEmail'
// 'keybase.1.emails.deleteEmail'
// 'keybase.1.emails.editEmail'
// 'keybase.1.emails.setPrimaryEmail'
// 'keybase.1.emails.sendVerificationEmail'
// 'keybase.1.emails.setVisibilityEmail'
// 'keybase.1.emails.setVisibilityAllEmail'
// 'keybase.1.emails.getEmails'
// 'keybase.1.favorite.getFavorites'
// 'keybase.1.fs.List'
// 'keybase.1.git.putGitMetadata'
// 'keybase.1.git.deleteGitMetadata'
// 'keybase.1.git.gcPersonalRepo'
// 'keybase.1.git.gcTeamRepo'
// 'keybase.1.git.getTeamRepoSettings'
// 'keybase.1.gpgUi.wantToAddGPGKey'
// 'keybase.1.gpgUi.confirmDuplicateKeyChosen'
// 'keybase.1.gpgUi.confirmImportSecretToExistingKey'
// 'keybase.1.gpgUi.selectKeyAndPushOption'
// 'keybase.1.gpgUi.selectKey'
// 'keybase.1.gpgUi.sign'
// 'keybase.1.gpgUi.getTTY'
// 'keybase.1.gregorUI.pushState'
// 'keybase.1.gregorUI.pushOutOfBandMessages'
// 'keybase.1.home.homeActionTaken'
// 'keybase.1.homeUI.homeUIRefresh'
// 'keybase.1.identify.Resolve3'
// 'keybase.1.identify.identifyLite'
// 'keybase.1.identify.resolveIdentifyImplicitTeam'
// 'keybase.1.identify.resolveImplicitTeam'
// 'keybase.1.identify.normalizeSocialAssertion'
// 'keybase.1.identify3Ui.identify3ShowTracker'
// 'keybase.1.identify3Ui.identify3UpdateRow'
// 'keybase.1.identify3Ui.identify3UserReset'
// 'keybase.1.identify3Ui.identify3UpdateUserCard'
// 'keybase.1.identify3Ui.identify3TrackerTimedOut'
// 'keybase.1.identify3Ui.identify3Result'
// 'keybase.1.identifyUi.displayTLFCreateWithInvite'
// 'keybase.1.identifyUi.delegateIdentifyUI'
// 'keybase.1.identifyUi.start'
// 'keybase.1.identifyUi.displayKey'
// 'keybase.1.identifyUi.reportLastTrack'
// 'keybase.1.identifyUi.launchNetworkChecks'
// 'keybase.1.identifyUi.displayTrackStatement'
// 'keybase.1.identifyUi.finishWebProofCheck'
// 'keybase.1.identifyUi.finishSocialProofCheck'
// 'keybase.1.identifyUi.displayCryptocurrency'
// 'keybase.1.identifyUi.displayStellarAccount'
// 'keybase.1.identifyUi.reportTrackToken'
// 'keybase.1.identifyUi.displayUserCard'
// 'keybase.1.identifyUi.confirm'
// 'keybase.1.identifyUi.cancel'
// 'keybase.1.identifyUi.finish'
// 'keybase.1.identifyUi.dismiss'
// 'keybase.1.implicitTeamMigration.startMigration'
// 'keybase.1.implicitTeamMigration.finalizeMigration'
// 'keybase.1.install.installCommandLinePrivileged'
// 'keybase.1.kbfs.FSEvent'
// 'keybase.1.kbfs.FSPathUpdate'
// 'keybase.1.kbfs.FSEditList'
// 'keybase.1.kbfs.FSSyncStatus'
// 'keybase.1.kbfs.FSSyncEvent'
// 'keybase.1.kbfs.FSOverallSyncEvent'
// 'keybase.1.kbfs.FSOnlineStatusChangedEvent'
// 'keybase.1.kbfs.FSFavoritesChangedEvent'
// 'keybase.1.kbfs.createTLF'
// 'keybase.1.kbfs.getKBFSTeamSettings'
// 'keybase.1.kbfs.upgradeTLF'
// 'keybase.1.kbfs.encryptFavorites'
// 'keybase.1.kbfs.decryptFavorites'
// 'keybase.1.KBFSGit.createRepo'
// 'keybase.1.KBFSGit.deleteRepo'
// 'keybase.1.KBFSGit.gc'
// 'keybase.1.kbfsMount.GetAllAvailableMountDirs'
// 'keybase.1.kbfsMount.SetCurrentMountDir'
// 'keybase.1.Kex2Provisionee.hello'
// 'keybase.1.Kex2Provisionee.didCounterSign'
// 'keybase.1.Kex2Provisionee2.hello2'
// 'keybase.1.Kex2Provisionee2.didCounterSign2'
// 'keybase.1.Kex2Provisioner.kexStart'
// 'keybase.1.log.registerLogger'
// 'keybase.1.logUi.log'
// 'keybase.1.login.loginProvisionedDevice'
// 'keybase.1.login.loginWithPaperKey'
// 'keybase.1.login.clearStoredSecret'
// 'keybase.1.login.recoverAccountFromEmailAddress'
// 'keybase.1.login.recoverPassphrase'
// 'keybase.1.login.unlock'
// 'keybase.1.login.unlockWithPassphrase'
// 'keybase.1.login.loginOneshot'
// 'keybase.1.loginUi.getEmailOrUsername'
// 'keybase.1.loginUi.promptRevokePaperKeys'
// 'keybase.1.loginUi.displayPaperKeyPhrase'
// 'keybase.1.loginUi.displayPrimaryPaperKey'
// 'keybase.1.loginUi.promptResetAccount'
// 'keybase.1.loginUi.displayResetProgress'
// 'keybase.1.loginUi.explainDeviceRecovery'
// 'keybase.1.loginUi.promptPassphraseRecovery'
// 'keybase.1.logsend.prepareLogsend'
// 'keybase.1.merkle.getCurrentMerkleRoot'
// 'keybase.1.merkle.verifyMerkleRootAndKBFS'
// 'keybase.1.metadata.getChallenge'
// 'keybase.1.metadata.authenticate'
// 'keybase.1.metadata.putMetadata'
// 'keybase.1.metadata.getMetadata'
// 'keybase.1.metadata.getMetadataByTimestamp'
// 'keybase.1.metadata.registerForUpdates'
// 'keybase.1.metadata.pruneBranch'
// 'keybase.1.metadata.putKeys'
// 'keybase.1.metadata.getKey'
// 'keybase.1.metadata.deleteKey'
// 'keybase.1.metadata.truncateLock'
// 'keybase.1.metadata.truncateUnlock'
// 'keybase.1.metadata.getFolderHandle'
// 'keybase.1.metadata.getFoldersForRekey'
// 'keybase.1.metadata.ping'
// 'keybase.1.metadata.ping2'
// 'keybase.1.metadata.getLatestFolderHandle'
// 'keybase.1.metadata.getKeyBundles'
// 'keybase.1.metadata.lock'
// 'keybase.1.metadata.releaseLock'
// 'keybase.1.metadata.startImplicitTeamMigration'
// 'keybase.1.metadata.getMerkleRoot'
// 'keybase.1.metadata.getMerkleRootLatest'
// 'keybase.1.metadata.getMerkleRootSince'
// 'keybase.1.metadata.getMerkleNode'
// 'keybase.1.metadata.findNextMD'
// 'keybase.1.metadata.setImplicitTeamModeForTest'
// 'keybase.1.metadata.forceMerkleBuildForTest'
// 'keybase.1.metadataUpdate.metadataUpdate'
// 'keybase.1.metadataUpdate.folderNeedsRekey'
// 'keybase.1.metadataUpdate.foldersNeedRekey'
// 'keybase.1.NotifyApp.exit'
// 'keybase.1.NotifyAudit.rootAuditError'
// 'keybase.1.NotifyAudit.boxAuditError'
// 'keybase.1.NotifyBadges.badgeState'
// 'keybase.1.NotifyCanUserPerform.canUserPerformChanged'
// 'keybase.1.NotifyDeviceClone.deviceCloneCountChanged'
// 'keybase.1.NotifyEmailAddress.emailAddressVerified'
// 'keybase.1.NotifyEphemeral.newTeamEk'
// 'keybase.1.NotifyFavorites.favoritesChanged'
// 'keybase.1.NotifyFS.FSActivity'
// 'keybase.1.NotifyFS.FSPathUpdated'
// 'keybase.1.NotifyFS.FSSyncActivity'
// 'keybase.1.NotifyFS.FSEditListResponse'
// 'keybase.1.NotifyFS.FSSyncStatusResponse'
// 'keybase.1.NotifyFS.FSOverallSyncStatusChanged'
// 'keybase.1.NotifyFS.FSFavoritesChanged'
// 'keybase.1.NotifyFS.FSOnlineStatusChanged'
// 'keybase.1.NotifyFSRequest.FSEditListRequest'
// 'keybase.1.NotifyFSRequest.FSSyncStatusRequest'
// 'keybase.1.NotifyKeyfamily.keyfamilyChanged'
// 'keybase.1.NotifyPaperKey.paperKeyCached'
// 'keybase.1.NotifyPGP.pgpKeyInSecretStoreFile'
// 'keybase.1.NotifyPhoneNumber.phoneNumberAdded'
// 'keybase.1.NotifyPhoneNumber.phoneNumberVerified'
// 'keybase.1.NotifyPhoneNumber.phoneNumberSuperseded'
// 'keybase.1.NotifyService.shutdown'
// 'keybase.1.NotifySession.loggedOut'
// 'keybase.1.NotifySession.loggedIn'
// 'keybase.1.NotifySession.clientOutOfDate'
// 'keybase.1.NotifyTeam.teamChangedByID'
// 'keybase.1.NotifyTeam.teamChangedByName'
// 'keybase.1.NotifyTeam.teamDeleted'
// 'keybase.1.NotifyTeam.teamAbandoned'
// 'keybase.1.NotifyTeam.teamExit'
// 'keybase.1.NotifyTeam.newlyAddedToTeam'
// 'keybase.1.NotifyTeam.avatarUpdated'
// 'keybase.1.NotifyTracking.trackingChanged'
// 'keybase.1.NotifyUnverifiedTeamList.teamListUnverifiedChanged'
// 'keybase.1.NotifyUsers.userChanged'
// 'keybase.1.NotifyUsers.passwordChanged'
// 'keybase.1.paperprovision.paperProvision'
// 'keybase.1.pgp.pgpSign'
// 'keybase.1.pgp.pgpPull'
// 'keybase.1.pgp.pgpEncrypt'
// 'keybase.1.pgp.pgpDecrypt'
// 'keybase.1.pgp.pgpVerify'
// 'keybase.1.pgp.pgpImport'
// 'keybase.1.pgp.pgpExport'
// 'keybase.1.pgp.pgpExportByFingerprint'
// 'keybase.1.pgp.pgpExportByKID'
// 'keybase.1.pgp.pgpKeyGen'
// 'keybase.1.pgp.pgpDeletePrimary'
// 'keybase.1.pgp.pgpSelect'
// 'keybase.1.pgp.pgpUpdate'
// 'keybase.1.pgp.pgpPurge'
// 'keybase.1.pgp.pgpPushPrivate'
// 'keybase.1.pgp.pgpPullPrivate'
// 'keybase.1.pgpUi.outputSignatureSuccess'
// 'keybase.1.pgpUi.outputSignatureSuccessNonKeybase'
// 'keybase.1.pgpUi.keyGenerated'
// 'keybase.1.pgpUi.shouldPushPrivate'
// 'keybase.1.pgpUi.finished'
// 'keybase.1.phoneNumbers.addPhoneNumber'
// 'keybase.1.phoneNumbers.editPhoneNumber'
// 'keybase.1.phoneNumbers.verifyPhoneNumber'
// 'keybase.1.phoneNumbers.getPhoneNumbers'
// 'keybase.1.phoneNumbers.deletePhoneNumber'
// 'keybase.1.phoneNumbers.setVisibilityPhoneNumber'
// 'keybase.1.phoneNumbers.setVisibilityAllPhoneNumber'
// 'keybase.1.pprof.processorProfile'
// 'keybase.1.pprof.trace'
// 'keybase.1.prove.listProofServices'
// 'keybase.1.prove.validateUsername'
// 'keybase.1.proveUi.promptOverwrite'
// 'keybase.1.proveUi.promptUsername'
// 'keybase.1.proveUi.outputPrechecks'
// 'keybase.1.proveUi.preProofWarning'
// 'keybase.1.proveUi.outputInstructions'
// 'keybase.1.proveUi.okToCheck'
// 'keybase.1.proveUi.checking'
// 'keybase.1.proveUi.continueChecking'
// 'keybase.1.proveUi.displayRecheckWarning'
// 'keybase.1.provisionUi.chooseProvisioningMethod'
// 'keybase.1.provisionUi.chooseGPGMethod'
// 'keybase.1.provisionUi.switchToGPGSignOK'
// 'keybase.1.provisionUi.chooseDevice'
// 'keybase.1.provisionUi.chooseDeviceType'
// 'keybase.1.provisionUi.DisplayAndPromptSecret'
// 'keybase.1.provisionUi.DisplaySecretExchanged'
// 'keybase.1.provisionUi.PromptNewDeviceName'
// 'keybase.1.provisionUi.ProvisioneeSuccess'
// 'keybase.1.provisionUi.ProvisionerSuccess'
// 'keybase.1.quota.verifySession'
// 'keybase.1.rekey.getPendingRekeyStatus'
// 'keybase.1.rekey.debugShowRekeyStatus'
// 'keybase.1.rekey.rekeySync'
// 'keybase.1.rekeyUI.delegateRekeyUI'
// 'keybase.1.rekeyUI.refresh'
// 'keybase.1.rekeyUI.rekeySendEvent'
// 'keybase.1.saltpack.saltpackEncrypt'
// 'keybase.1.saltpack.saltpackDecrypt'
// 'keybase.1.saltpack.saltpackSign'
// 'keybase.1.saltpack.saltpackVerify'
// 'keybase.1.saltpackUi.saltpackPromptForDecrypt'
// 'keybase.1.saltpackUi.saltpackVerifySuccess'
// 'keybase.1.saltpackUi.saltpackVerifyBadSender'
// 'keybase.1.ScanProofs.scanProofs'
// 'keybase.1.secretUi.getPassphrase'
// 'keybase.1.SecretKeys.getSecretKeys'
// 'keybase.1.selfprovision.selfProvision'
// 'keybase.1.session.currentSession'
// 'keybase.1.session.sessionPing'
// 'keybase.1.sigs.sigList'
// 'keybase.1.sigs.sigListJSON'
// 'keybase.1.SimpleFS.simpleFSListRecursive'
// 'keybase.1.SimpleFS.simpleFSCopy'
// 'keybase.1.SimpleFS.simpleFSSymlink'
// 'keybase.1.SimpleFS.simpleFSRename'
// 'keybase.1.SimpleFS.simpleFSSetStat'
// 'keybase.1.SimpleFS.simpleFSRead'
// 'keybase.1.SimpleFS.simpleFSWrite'
// 'keybase.1.SimpleFS.simpleFSGetRevisions'
// 'keybase.1.SimpleFS.simpleFSReadRevisions'
// 'keybase.1.SimpleFS.simpleFSMakeOpid'
// 'keybase.1.SimpleFS.simpleFSClose'
// 'keybase.1.SimpleFS.simpleFSGetOps'
// 'keybase.1.SimpleFS.simpleFSDumpDebuggingInfo'
// 'keybase.1.SimpleFS.simpleFSForceStuckConflict'
// 'keybase.1.SimpleFS.simpleFSFolderEditHistory'
// 'keybase.1.SimpleFS.simpleFSGetUserQuotaUsage'
// 'keybase.1.SimpleFS.simpleFSGetTeamQuotaUsage'
// 'keybase.1.SimpleFS.simpleFSReset'
// 'keybase.1.SimpleFS.simpleFSSetDebugLevel'
// 'keybase.1.streamUi.close'
// 'keybase.1.streamUi.read'
// 'keybase.1.streamUi.reset'
// 'keybase.1.streamUi.write'
// 'keybase.1.teams.teamCreateWithSettings'
// 'keybase.1.teams.teamImplicitAdmins'
// 'keybase.1.teams.teamListTeammates'
// 'keybase.1.teams.teamListVerified'
// 'keybase.1.teams.teamListSubteamsRecursive'
// 'keybase.1.teams.teamChangeMembership'
// 'keybase.1.teams.teamAddMembersMultiRole'
// 'keybase.1.teams.teamAcceptInvite'
// 'keybase.1.teams.teamRequestAccess'
// 'keybase.1.teams.teamTree'
// 'keybase.1.teams.teamDelete'
// 'keybase.1.teams.teamCreateSeitanToken'
// 'keybase.1.teams.lookupImplicitTeam'
// 'keybase.1.teams.lookupOrCreateImplicitTeam'
// 'keybase.1.teams.loadTeamPlusApplicationKeys'
// 'keybase.1.teams.getTeamRootID'
// 'keybase.1.teams.getTeamShowcase'
// 'keybase.1.teams.teamRotateKey'
// 'keybase.1.teams.teamDebug'
// 'keybase.1.teams.tryDecryptWithTeamKey'
// 'keybase.1.teams.findNextMerkleRootAfterTeamRemoval'
// 'keybase.1.teams.findNextMerkleRootAfterTeamRemovalBySigningKey'
// 'keybase.1.teams.profileTeamLoad'
// 'keybase.1.teams.getTeamID'
// 'keybase.1.teams.ftl'
// 'keybase.1.teamsUi.confirmRootTeamDelete'
// 'keybase.1.teamsUi.confirmSubteamDelete'
// 'keybase.1.test.test'
// 'keybase.1.test.testCallback'
// 'keybase.1.test.panic'
// 'keybase.1.tlf.CryptKeys'
// 'keybase.1.tlf.publicCanonicalTLFNameAndID'
// 'keybase.1.tlf.completeAndCanonicalizePrivateTlfName'
// 'keybase.1.tlfKeys.getTLFCryptKeys'
// 'keybase.1.tlfKeys.getPublicCanonicalTLFNameAndID'
// 'keybase.1.track.track'
// 'keybase.1.track.fakeTrackingChanged'
// 'keybase.1.ui.promptYesNo'
// 'keybase.1.user.listTrackers'
// 'keybase.1.user.listTrackersByName'
// 'keybase.1.user.listTrackersSelf'
// 'keybase.1.user.loadUncheckedUserSummaries'
// 'keybase.1.user.loadUser'
// 'keybase.1.user.loadUserByName'
// 'keybase.1.user.loadUserPlusKeys'
// 'keybase.1.user.loadUserPlusKeysV2'
// 'keybase.1.user.loadPublicKeys'
// 'keybase.1.user.loadMyPublicKeys'
// 'keybase.1.user.listTracking'
// 'keybase.1.user.listTrackingJSON'
// 'keybase.1.user.loadAllPublicKeysUnverified'
// 'keybase.1.user.meUserVersion'
// 'keybase.1.user.getUPAK'
// 'keybase.1.user.getUPAKLite'
// 'keybase.1.user.findNextMerkleRootAfterRevoke'
// 'keybase.1.user.findNextMerkleRootAfterReset'
// 'keybase.1.user.userCard'
